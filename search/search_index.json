{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Chatterjee's Xi, its Applications, and Offshoots","text":"<p>XicorPy is a Python package implementing Chatterjee's Xi, and its various offshoots.</p> <p>The package currently implements:   </p> <ol> <li>Chatterjee's Xi1</li> <li>Modified Xi2</li> <li>Conditional Dependence Coefficient3</li> <li>Feature Selection via Feature Ordering by Conditional Independence (FOCI) Algorithm 3</li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>The package is available on PyPI. You can install using pip: <code>pip install xicorpy</code>.</p>"},{"location":"#usage","title":"Usage","text":"<p>Compute Chatterjee's Xi:</p> <pre><code>import xicorpy\n\nx = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5]\ny = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68]\nxi = xicorpy.compute_xi_correlation(x, y)\n\nxi, p_value = xicorpy.compute_xi_correlation(x, y, get_p_values=True)\n\n</code></pre> <p>Compute Conditional Dependence Coefficient:</p> <pre><code>import numpy as np\nimport xicorpy\n\nn = 10000\np = 3\nx = np.random.uniform(0, 1, (n, p))\n\n# y is independent of each x, but is a function of all three put together\ny = np.mod(x.sum(axis=1), 1)\n\n# y is independent of x, so coeff is 0. \nc = xicorpy.compute_conditional_dependence(y, x[:, 0])\nassert np.allclose(c, 0, atol=1e-2)\n\n# y is a function of all three put together. Now coeff is close to 1.\nc = xicorpy.compute_conditional_dependence(y, x)\nassert np.allclose(c, 1, atol=2e-1)\n\n# Given col1, and col2, y is a function of col3.\nc = xicorpy.compute_conditional_dependence(y, x[:, 0], x[:, 1:])\nassert np.allclose(c, 1, atol=1e-2)\n</code></pre> <p>Select Features using FOCI:</p> <pre><code>import numpy as np\nimport xicorpy\n\n\nn = 2000\np = 100\nx = np.random.normal(0, 1, (n, p))\ny = x[:, 0] * x[:, 1] + np.sin(x[:, 2] * x[:, 0])\n\n# Select Features\nselected = xicorpy.select_features_using_foci(y, x, num_features=10)\n\n# Select Features with Initial Feature Set\nselected = xicorpy.select_features_using_foci(y, x, num_features=10, init_selection=[0])\n</code></pre>"},{"location":"#citations","title":"Citations","text":"<ol> <li> <p>Chatterjee (2020). \"A new coefficient of correlation\" \u21a9</p> </li> <li> <p>Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" \u21a9</p> </li> <li> <p>Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\" \u21a9\u21a9</p> </li> </ol>"},{"location":"codec/","title":"Conditional Dependence Coefficient","text":"<p>Conditional Dependence Coefficient1 measures if <code>Y is a function of Z|X</code> (represented at <code>T(Y, Z|X)</code>), where Z and X can both be multi-variate. When <code>X</code> is not present, it reduces to <code>T(Y, Z)</code>.</p> <p>The coefficient is computed by comparing the nearest neighbour of consecutive rows of Z when Y is sorted. It is 0 if <code>Y</code> is completely independent of <code>Z|X</code>, and 1 if <code>Y</code> is a measurable function of <code>Z|X</code>.</p>"},{"location":"codec/#usage","title":"Usage","text":"<p>Make a random 10000 x 3 array: </p> <p>Y is independent of each column. But it is a function of all three put together.</p> <pre><code>import numpy as np\n\nn = 10000\np = 3\nx = np.random.uniform(0, 1, (n, p))\n\n# y is independent of each x, but is a function of all three put together\ny = np.mod(x.sum(axis=1), 1)\n\n</code></pre> <p>Compute <code>T(Y, Z)</code>:</p> <pre><code>import xicorpy\n\n# y is independent of x, so coeff is 0. \nc = xicorpy.compute_conditional_dependence(y, x[:, 0])\nassert np.allclose(c, 0, atol=1e-2)\n\n# y is independent of any two x columns too, so coeff is again 0.\nc = xicorpy.compute_conditional_dependence(y, x[:, :1])\nassert np.allclose(c, 0, atol=1e-2)\nc = xicorpy.compute_conditional_dependence(y, x[:, 1:])\nassert np.allclose(c, 0, atol=1e-2)\n\n# y is a function of all three put together. Now coeff is close to 1.\nc = xicorpy.compute_conditional_dependence(y, x)\nassert np.allclose(c, 1, atol=1e-1)\n</code></pre> <p>Compute <code>T(Y, Z | X)</code>:</p> <pre><code># Given col1, and col2, y is a function of col3.\nc = xicorpy.compute_conditional_dependence(y, x[:, 0], x[:, 1:])\nassert np.allclose(c, 1, atol=1e-2)\n</code></pre> <p>Compute coefficient for each column of X:</p> <pre><code>c = xicorpy.compute_conditional_dependence_1d(y, x)\nassert isinstance(c, dict)\nassert sorted(c.keys()) == [0, 1, 2]\n\nc = xicorpy.compute_conditional_dependence_1d(y, x[:, :2], x[:, 2])\nassert isinstance(c, dict)\nassert sorted(c.keys()) == [0, 1]\n</code></pre>"},{"location":"codec/#citations","title":"Citations","text":"<ol> <li> <p>Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics \u21a9</p> </li> </ol>"},{"location":"codec_api/","title":"Workflow module","text":""},{"location":"codec_api/#xicorpy.conditional_dependence.ConditionalDependence","title":"<code>ConditionalDependence</code>","text":"<p>Class containing methods for calculating conditional dependence.</p>"},{"location":"codec_api/#xicorpy.conditional_dependence.ConditionalDependence.__init__","title":"<code>__init__(y, z)</code>","text":"<p>Initialize and Validate a ConditionalDependence object.</p> <p>You can then pass any X values to <code>compute_conditional_dependence</code> and <code>compute_conditional_dependence_1d</code></p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>npt.ArrayLike</code> <p>A single list or 1D array or a pandas Series.</p> required <code>z</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If y is not 1d.</p> <code>ValueError</code> <p>If z is not 1d or 2d.</p> <code>ValueError</code> <p>If y and z have different lengths.</p> <code>ValueError</code> <p>If there are &lt;= 2 valid y values.</p>"},{"location":"codec_api/#xicorpy.conditional_dependence.ConditionalDependence.compute_conditional_dependence","title":"<code>compute_conditional_dependence(x=None)</code>","text":"Compute conditional dependence coefficient based on <p>Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics</p> <p>If X is passed, computes <code>T(Y, Z|X)</code> where <code>T</code> is the conditional dependence coefficient. Otherwise, computes <code>T(Y, Z)</code>.</p> <p>Conditional Dependence Coefficient lies between 0 and 1, and is</p> <pre><code>0 if Y is completely independent of Z|X\n1 if Y is a measurable function of Z|X\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <p>Conditional Dependence Coefficient.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If x is passed, and not same number of rows as y.</p>"},{"location":"codec_api/#xicorpy.conditional_dependence.ConditionalDependence.compute_conditional_dependence_1d","title":"<code>compute_conditional_dependence_1d(x=None)</code>","text":"<p>Computes conditional dependence of y on each column of z individually.</p> <p>Use when you want to compute <code>T(Y, Z_j|X)</code> for each column of Z.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Keys are column names (or indices if x is not a pandas object), and values are conditional dependence coefficients.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If x is passed, and does not have same number of rows as y.</p>"},{"location":"codec_api/#xicorpy.conditional_dependence.compute_conditional_dependence","title":"<code>compute_conditional_dependence(y, z, x=None)</code>","text":"Compute conditional dependence coefficient based on <p>Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics</p> <p>If X is passed, computes <code>T(Y, Z|X)</code> where <code>T</code> is the conditional dependence coefficient. Otherwise, computes <code>T(Y, Z)</code>.</p> <p>Conditional Dependence Coefficient lies between 0 and 1, and is</p> <pre><code>0 if Y is completely independent of Z|X\n1 if Y is a measurable function of Z|X\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>npt.ArrayLike</code> <p>A single list or 1D array or a pandas Series.</p> required <code>z</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> required <code>x</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Conditional Dependence Coefficient.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If y is not 1d.</p> <code>ValueError</code> <p>If z is not 1d or 2d.</p> <code>ValueError</code> <p>If y and z have different lengths.</p> <code>ValueError</code> <p>If there are &lt;= 2 valid y values.</p> <code>ValueError</code> <p>If x is passed, and not same number of rows as y.</p>"},{"location":"codec_api/#xicorpy.conditional_dependence.compute_conditional_dependence_1d","title":"<code>compute_conditional_dependence_1d(y, z, x=None)</code>","text":"<p>Computes conditional dependence of y on each column of z individually.</p> <p>Use when you want to compute <code>T(Y, Z_j|X)</code> for each column of Z.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>npt.ArrayLike</code> <p>A single list or 1D array or a pandas Series.</p> required <code>z</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> required <code>x</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[Union[str, int], float]</code> <p>Keys are column names (or indices if x is not a pandas object), and values are conditional dependence coefficients.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If y is not 1d.</p> <code>ValueError</code> <p>If z is not 1d or 2d.</p> <code>ValueError</code> <p>If y and z have different lengths.</p> <code>ValueError</code> <p>If there are &lt;= 2 valid y values.</p> <code>ValueError</code> <p>If x is passed, and does not have the same number of rows as y.</p>"},{"location":"foci/","title":"Feature Ordering by Conditional Dependence (FOCI)","text":"<p>FOCI1 is a forward stepwise feature selection algorithm  for multivariate regression based on Conditional Dependence measure.</p>"},{"location":"foci/#usage","title":"Usage","text":"<p>Make a random <code>2000x100</code> array of independent variables, and simulate a complex <code>Y</code></p> <pre><code>import numpy as np\n\n\nn = 2000\np = 100\nx = np.random.normal(0, 1, (n, p))\ny = x[:, 0] * x[:, 1] + np.sin(x[:, 2] * x[:, 0])\n</code></pre> <p>Select Features</p> <pre><code>import xicorpy\n\nselected = xicorpy.select_features_using_foci(y, x, num_features=10)\n</code></pre> <p>Select Features with Initial Feature Set</p> <pre><code>import xicorpy\n\nselected = xicorpy.select_features_using_foci(y, x, num_features=10, init_selection=[0])\n</code></pre>"},{"location":"foci/#citations","title":"Citations","text":"<ol> <li> <p>Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics \u21a9</p> </li> </ol>"},{"location":"foci_api/","title":"FOCI module","text":""},{"location":"foci_api/#xicorpy.foci.FOCI","title":"<code>FOCI</code>","text":"<p>Class for computing FOCI.</p>"},{"location":"foci_api/#xicorpy.foci.FOCI.__init__","title":"<code>__init__(y, x)</code>","text":"<p>Initialize and validate the FOCI object.</p> <p>You can then use the <code>select_features</code> method to select features.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>npt.ArrayLike</code> <p>A single list or 1D array or a pandas Series.</p> required <code>x</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If y is not 1d.</p> <code>ValueError</code> <p>If x is not 1d or 2d.</p> <code>ValueError</code> <p>If y and x have different lengths.</p> <code>ValueError</code> <p>If there are &lt;= 2 valid y values.</p>"},{"location":"foci_api/#xicorpy.foci.FOCI.select_features","title":"<code>select_features(num_features=None, init_selection=None)</code>","text":"<p>Selects features based on the Feature Ordering based on Conditional Independence (FOCI) algorithm in:     Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics</p> <p>Parameters:</p> Name Type Description Default <code>num_features</code> <code>int</code> <p>Maximum number of features to select. Defaults to the number of features in x.</p> <code>None</code> <code>init_selection</code> <code>list</code> <p>Initial selection of features.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <code>List[Union[int, str]]</code> <p>List of selected features. If x was <code>pd.DataFrame</code>, this will be column names. Otherwise, this will be indices.</p>"},{"location":"foci_api/#xicorpy.foci.select_features_using_foci","title":"<code>select_features_using_foci(y, x, num_features=None, init_selection=None)</code>","text":"<p>Implements the FOCI algorithm for feature selection.</p> <p>Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics. https://arxiv.org/abs/1910.12327.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>npt.ArrayLike</code> <p>The dependent variable. A single list or 1D array or a pandas Series.</p> required <code>x</code> <code>npt.ArrayLike</code> <p>The independent variables. A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> required <code>num_features</code> <code>int</code> <p>Max number of features to select. Defaults to ALL features.</p> <code>None</code> <code>init_selection</code> <code>list</code> <p>Initial selection of features. If <code>x</code> is a <code>pd.DataFrame</code>, this is expected to be a list of column names. Otherwise, this is expected to be a list of indices.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>list</code> <code>List[Union[int, str]]</code> <p>List of selected features. If x was <code>pd.DataFrame</code>, this will be column names. Otherwise, this will be indices.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If y is not 1d.</p> <code>ValueError</code> <p>If x is not 1d or 2d.</p> <code>ValueError</code> <p>If y and x have different lengths.</p> <code>ValueError</code> <p>If there are &lt;= 2 valid y values.</p>"},{"location":"xi/","title":"Chatterjee's Xi Coefficient","text":"<p>Chatterjee's Xi1 measures if <code>Y is a function of X</code>.  The coefficient is 0 if X and Y are independent, and 1 if Y is a measurable function of X.  Xi is computed by comparing ranks of consecutive values of X when Y is sorted. </p> <p>Lin and Han's 2 modification makes the original formulation more robust by comparing M right-neighbours.  When M == 1, it reduces to the original formulation.</p> <p>Do note that this formulation is <code>asymmetric</code>:</p> <pre><code>Xi(X, Y): Measures Y as a function of X\nXi(Y, X): Measures X as a function of Y \n\nXi(X, Y) != Xi(Y, X)\n</code></pre> <p>To illustrate this better, consider the following example:</p> X Y 8 6.58 8 5.76 8 7.71 8 8.84 8 8.47 8 7.04 8 5.25 19 12.5 8 5.56 8 7.91 8 6.89 <p>This is the 4th dataset of Anscombe\u2019s quartet</p> <p>While we cannot have an estimate of Y given X, we can estimate X given Y - <code>If Y &lt; 10: X = 8, else X = 19</code>.</p> Direction Chatterjee's Xi Modified Xi Xi(X, Y) 0.175 0.111 Xi(Y, X) 0.45 0.75 <p>The above table also illustrates the impact of Lin and Han's modification.  For very large data, the two are likely to be very similar, and for smaller data, Lin and Han's formulation tends to be appropriate.</p>"},{"location":"xi/#usage","title":"Usage","text":"<pre><code>import xicorpy\n\nx = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5]\ny = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68]\nxi = xicorpy.compute_xi_correlation(x, y)\n\n## Get p-values:\nxi, p_value = xicorpy.compute_xi_correlation(x, y, get_p_values=True)\n\n## Explicitly specify m-nearest-neighbours:\nxi = xicorpy.compute_xi_correlation(x, y, m_nearest_neighbours=5)\n\n## Compute original formulation without Lin and Han's Modification:\nxi = xicorpy.compute_xi_correlation(x, y, get_modified_xi=False)\n\n</code></pre> <p>Compute correlations between all columns in X vs all columns in Y:</p> <pre><code>\nimport pandas as pd\nimport xicorpy\n\nx = pd.DataFrame({\n    \"x_1\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5],\n    \"x_2\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5],\n    \"x_3\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5],\n    \"x_4\": [8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8],\n})\ny = pd.DataFrame({\n    \"y_1\": [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68],\n    \"y_2\": [9.14, 8.14, 8.74, 8.77, 9.26, 8.1, 6.13, 3.1, 9.13, 7.26, 4.74],\n    \"y_3\": [7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73],\n    \"y_4\": [6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.5, 5.56, 7.91, 6.89],\n})\n\nxi = xicorpy.compute_xi_correlation(x, y)\n</code></pre> <p>Compute correlations between all columns in X:</p> <pre><code>\nimport pandas as pd\nimport xicorpy\n\nx = pd.DataFrame({\n    \"x_1\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5],\n    \"x_2\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5],\n    \"y_1\": [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68],\n    \"y_2\": [9.14, 8.14, 8.74, 8.77, 9.26, 8.1, 6.13, 3.1, 9.13, 7.26, 4.74],\n})\n\nxi = xicorpy.compute_xi_correlation(x)\n</code></pre>"},{"location":"xi/#citations","title":"Citations","text":"<ol> <li> <p>Chatterjee (2020). \"A new coefficient of correlation\" \u21a9</p> </li> <li> <p>Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" \u21a9</p> </li> </ol>"},{"location":"xicor_api/","title":"Workflow module","text":""},{"location":"xicor_api/#xicorpy.correlation.XiCorrelation","title":"<code>XiCorrelation</code>","text":"<p>Class containing Xi Correlation computation components</p>"},{"location":"xicor_api/#xicorpy.correlation.XiCorrelation.__init__","title":"<code>__init__(x, y=None)</code>","text":"<p>If only <code>x</code> is passed, computes correlation between each column of <code>x</code>. If <code>y</code> is also passed, computes correlation between each column of <code>x</code> vs each column of <code>y</code>.</p> <p>If only <code>x</code> is passed, <code>x</code> MUST be 2-d. Otherwise, both <code>x</code> and <code>y</code> can be 1-d</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> required <code>y</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If x and y are not of the same shape.</p> <code>ValueError</code> <p>If there's less than 2 columns to compute correlation.</p>"},{"location":"xicor_api/#xicorpy.correlation.XiCorrelation.compute_xi","title":"<code>compute_xi(get_modified_xi=None, m_nearest_neighbours=None, get_p_values=False)</code>","text":"<p>Compute the Xi Coefficient (Chatterjee's Rank Correlation) between columns in X and Y.</p> Xi Coefficient based on <p>Chatterjee (2020). \"A new coefficient of correlation\"</p> Modified Xi Coefficient based on <p>Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\"</p> <p>The modified Xi Coefficient looks at M nearest neighbours to compute the correlation. This allows the coefficient to converge much faster. However, it is computationally slightly more intensive. For very large data, the two are likely to be very similar. We recommend using the modified Xi Coefficient.</p> <p>Parameters:</p> Name Type Description Default <code>get_modified_xi</code> <code>bool</code> <p>Should the modified xi be computed?     Defaults to True when there are no ties, and False when ties are present.</p> <code>None</code> <code>m_nearest_neighbours</code> <code>int</code> <p>Only used when get_modified_xi is True.     Defaults to square-root of array size.</p> <code>None</code> <code>get_p_values</code> <code>bool</code> <p>Should the p-values be computed?     The null hypothesis is that Y is completely independent of X (i.e., xi = 0).</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[_RetType, Tuple[_RetType, _RetType]]</code> <p>float/np.ndarray/pd.DataFrame:</p> <code>Union[_RetType, Tuple[_RetType, _RetType]]</code> <ul> <li>Xi Coefficient Values.</li> <li>If both X and Y are 1-d, returns a single float.</li> <li>If X is numpy object, returns a 2-D numpy array.</li> <li>Otherwise returns a pd.DataFrame.</li> </ul> <code>Union[_RetType, Tuple[_RetType, _RetType]]</code> <ul> <li>P-Values (only when get_p_values are true):</li> <li>Same format at Xi</li> </ul>"},{"location":"xicor_api/#xicorpy.correlation.compute_xi_correlation","title":"<code>compute_xi_correlation(x, y=None, get_modified_xi=None, m_nearest_neighbours=None, get_p_values=False)</code>","text":"<p>Helper function to compute the Xi Coefficient - uses the class machinery from <code>XiCorrelation</code>.</p> <p>Compute the Xi Coefficient (Chatterjee's Rank Correlation) between columns in X and Y.</p> Xi Coefficient based on <p>Chatterjee (2020). \"A new coefficient of correlation\"</p> Modified Xi Coefficient based on <p>Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\"</p> <p>The modified Xi Coefficient looks at M nearest neighbours to compute the correlation. This allows the coefficient to converge much faster. However, it is computationally slightly more intensive. For very large data, the two are likely to be very similar. We recommend using the modified Xi Coefficient.</p> <p>If only X is passed, computes correlation between each column of X. If Y is also passed, computes correlation between each column of X vs each column of Y.</p> <p>If only X is passed, X MUST be 2-d. Otherwise, both X and Y can be 1-d</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> required <code>y</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> <code>None</code> <code>get_modified_xi</code> <code>bool</code> <p>Should the modified xi be computed? By default this is True when there are no ties and False when ties are present</p> <code>None</code> <code>m_nearest_neighbours</code> <code>int</code> <p>Only used if get_modified_xi is True.</p> <code>None</code> <code>get_p_values</code> <code>bool</code> <p>Should the p-values be computed?             The null hypothesis is that Y is completely independent of X (i.e., xi = 0).</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[_RetType, Tuple[_RetType, _RetType]]</code> <p>float/np.ndarray/pd.DataFrame:</p> <code>Union[_RetType, Tuple[_RetType, _RetType]]</code> <ul> <li>Xi Coefficient Values.</li> <li>If both X and Y are 1-d, returns a single float.</li> <li>If X is numpy object, returns a 2-D numpy array.</li> <li>Otherwise returns a pd.DataFrame.</li> </ul> <code>Union[_RetType, Tuple[_RetType, _RetType]]</code> <ul> <li>P-Values (only if get_p_values are true):</li> <li>Same format at Xi</li> </ul>"}]}
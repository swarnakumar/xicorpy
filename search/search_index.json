{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Chatterjee's Xi, its Applications, and Offshoots XicorPy is a Python package implementing Chatterjee's Xi, and its various offshoots. The package currently implements: Chatterjee's Xi 1 Modified Xi 2 Conditional Dependence Coefficient 3 Feature Selection via Feature Ordering by Conditional Independence (FOCI) Algorithm 3 Installation The package is available on PyPI. You can install using pip: pip install xicorpy . Usage Compute Chatterjee's Xi: import xicorpy x = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5] y = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68] xi = xicorpy.compute_xi_correlation(x, y) xi, p_value = xicorpy.compute_xi_correlation(x, y, get_p_values=True) Compute Conditional Dependence Coefficient: import numpy as np import xicorpy n = 10000 p = 3 x = np.random.uniform(0, 1, (n, p)) # y is independent of each x, but is a function of all three put together y = np.mod(x.sum(axis=1), 1) # y is independent of x, so coeff is 0. c = xicorpy.compute_conditional_dependence(y, x[:, 0]) assert np.allclose(c, 0, atol=1e-2) # y is a function of all three put together. Now coeff is close to 1. c = xicorpy.compute_conditional_dependence(y, x) assert np.allclose(c, 1, atol=1e-1) # Given col1, and col2, y is a function of col3. c = xicorpy.compute_conditional_dependence(y, x[:, 0], x[:, 1:]) assert np.allclose(c, 1, atol=1e-2) Select Features using FOCI: import numpy as np import xicorpy n = 2000 p = 100 x = np.random.normal(0, 1, (n, p)) y = x[:, 0] * x[:, 1] + np.sin(x[:, 2] * x[:, 0]) # Select Features selected = xicorpy.select_features_using_foci(y, x, num_features=10) # Select Features with Initial Feature Set selected = xicorpy.select_features_using_foci(y, x, num_features=10, init_selection=[0]) Citations Chatterjee (2020). \"A new coefficient of correlation\" \u21a9 Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" \u21a9 Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\" \u21a9 \u21a9","title":"Home"},{"location":"#chatterjees-xi-its-applications-and-offshoots","text":"XicorPy is a Python package implementing Chatterjee's Xi, and its various offshoots. The package currently implements: Chatterjee's Xi 1 Modified Xi 2 Conditional Dependence Coefficient 3 Feature Selection via Feature Ordering by Conditional Independence (FOCI) Algorithm 3","title":"Chatterjee's Xi, its Applications, and Offshoots"},{"location":"#installation","text":"The package is available on PyPI. You can install using pip: pip install xicorpy .","title":"Installation"},{"location":"#usage","text":"Compute Chatterjee's Xi: import xicorpy x = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5] y = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68] xi = xicorpy.compute_xi_correlation(x, y) xi, p_value = xicorpy.compute_xi_correlation(x, y, get_p_values=True) Compute Conditional Dependence Coefficient: import numpy as np import xicorpy n = 10000 p = 3 x = np.random.uniform(0, 1, (n, p)) # y is independent of each x, but is a function of all three put together y = np.mod(x.sum(axis=1), 1) # y is independent of x, so coeff is 0. c = xicorpy.compute_conditional_dependence(y, x[:, 0]) assert np.allclose(c, 0, atol=1e-2) # y is a function of all three put together. Now coeff is close to 1. c = xicorpy.compute_conditional_dependence(y, x) assert np.allclose(c, 1, atol=1e-1) # Given col1, and col2, y is a function of col3. c = xicorpy.compute_conditional_dependence(y, x[:, 0], x[:, 1:]) assert np.allclose(c, 1, atol=1e-2) Select Features using FOCI: import numpy as np import xicorpy n = 2000 p = 100 x = np.random.normal(0, 1, (n, p)) y = x[:, 0] * x[:, 1] + np.sin(x[:, 2] * x[:, 0]) # Select Features selected = xicorpy.select_features_using_foci(y, x, num_features=10) # Select Features with Initial Feature Set selected = xicorpy.select_features_using_foci(y, x, num_features=10, init_selection=[0])","title":"Usage"},{"location":"#citations","text":"Chatterjee (2020). \"A new coefficient of correlation\" \u21a9 Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" \u21a9 Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\" \u21a9 \u21a9","title":"Citations"},{"location":"codec/","text":"Conditional Dependence Coefficient Conditional Dependence Coefficient 1 measures if Y is a function of Z|X (represented at T(Y, Z|X) ), where Z and X can both be multi-variate. When X is not present, it reduces to T(Y, Z) . The coefficient is computed by comparing the nearest neighbour of consecutive rows of Z when Y is sorted. It is 0 if Y is completely independent of Z|X , and 1 if Y is a measurable function of Z|X . Usage Make a random 10000 x 3 array: Y is independent of each column. But it is a function of all three put together. import numpy as np n = 10000 p = 3 x = np.random.uniform(0, 1, (n, p)) # y is independent of each x, but is a function of all three put together y = np.mod(x.sum(axis=1), 1) Compute T(Y, Z) : import xicorpy # y is independent of x, so coeff is 0. c = xicorpy.compute_conditional_dependence(y, x[:, 0]) assert np.allclose(c, 0, atol=1e-2) # y is independent of any two x columns too, so coeff is again 0. c = xicorpy.compute_conditional_dependence(y, x[:, :1]) assert np.allclose(c, 0, atol=1e-2) c = xicorpy.compute_conditional_dependence(y, x[:, 1:]) assert np.allclose(c, 0, atol=1e-2) # y is a function of all three put together. Now coeff is close to 1. c = xicorpy.compute_conditional_dependence(y, x) assert np.allclose(c, 1, atol=1e-1) Compute T(Y, Z | X) : # Given col1, and col2, y is a function of col3. c = xicorpy.compute_conditional_dependence(y, x[:, 0], x[:, 1:]) assert np.allclose(c, 1, atol=1e-2) Compute coefficient for each column of X: c = xicorpy.compute_conditional_dependence_1d(y, x) assert isinstance(c, dict) assert sorted(c.keys()) == [0, 1, 2] c = xicorpy.compute_conditional_dependence_1d(y, x[:, :2], x[:, 2]) assert isinstance(c, dict) assert sorted(c.keys()) == [0, 1] Citations Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics \u21a9","title":"Conditional Dependence"},{"location":"codec/#conditional-dependence-coefficient","text":"Conditional Dependence Coefficient 1 measures if Y is a function of Z|X (represented at T(Y, Z|X) ), where Z and X can both be multi-variate. When X is not present, it reduces to T(Y, Z) . The coefficient is computed by comparing the nearest neighbour of consecutive rows of Z when Y is sorted. It is 0 if Y is completely independent of Z|X , and 1 if Y is a measurable function of Z|X .","title":"Conditional Dependence Coefficient"},{"location":"codec/#usage","text":"Make a random 10000 x 3 array: Y is independent of each column. But it is a function of all three put together. import numpy as np n = 10000 p = 3 x = np.random.uniform(0, 1, (n, p)) # y is independent of each x, but is a function of all three put together y = np.mod(x.sum(axis=1), 1) Compute T(Y, Z) : import xicorpy # y is independent of x, so coeff is 0. c = xicorpy.compute_conditional_dependence(y, x[:, 0]) assert np.allclose(c, 0, atol=1e-2) # y is independent of any two x columns too, so coeff is again 0. c = xicorpy.compute_conditional_dependence(y, x[:, :1]) assert np.allclose(c, 0, atol=1e-2) c = xicorpy.compute_conditional_dependence(y, x[:, 1:]) assert np.allclose(c, 0, atol=1e-2) # y is a function of all three put together. Now coeff is close to 1. c = xicorpy.compute_conditional_dependence(y, x) assert np.allclose(c, 1, atol=1e-1) Compute T(Y, Z | X) : # Given col1, and col2, y is a function of col3. c = xicorpy.compute_conditional_dependence(y, x[:, 0], x[:, 1:]) assert np.allclose(c, 1, atol=1e-2) Compute coefficient for each column of X: c = xicorpy.compute_conditional_dependence_1d(y, x) assert isinstance(c, dict) assert sorted(c.keys()) == [0, 1, 2] c = xicorpy.compute_conditional_dependence_1d(y, x[:, :2], x[:, 2]) assert isinstance(c, dict) assert sorted(c.keys()) == [0, 1]","title":"Usage"},{"location":"codec/#citations","text":"Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics \u21a9","title":"Citations"},{"location":"codec_api/","text":"Workflow module ConditionalDependence Class containing methods for calculating conditional dependence. __init__ ( self , y , z ) special Initialize and Validate a ConditionalDependence object. You can then pass any X values to compute_conditional_dependence and compute_conditional_dependence_1d Parameters: Name Type Description Default y npt.ArrayLike A single list or 1D array or a pandas Series. required z npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required Exceptions: Type Description ValueError If y is not 1d. ValueError If z is not 1d or 2d. ValueError If y and z have different lengths. ValueError If there are <= 2 valid y values. compute_conditional_dependence ( self , x = None ) Compute conditional dependence coefficient based on: Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics If X is passed, computes T(Y, Z|X) where T is the conditional dependence coefficient. Otherwise, computes T(Y, Z) . Conditional Dependence Coefficient lies between 0 and 1, and is 0 if Y is completely independent of Z|X 1 if Y is a measurable function of Z|X Parameters: Name Type Description Default x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None Returns: Type Description float Conditional Dependence Coefficient. Exceptions: Type Description ValueError If x is passed, and not same number of rows as y. compute_conditional_dependence_1d ( self , x = None ) Computes conditional dependence of y on each column of z individually. Use when you want to compute T(Y, Z_j|X) for each column of Z. Parameters: Name Type Description Default x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None Returns: Type Description dict Keys are column names (or indices if x is not a pandas object), and values are conditional dependence coefficients. Exceptions: Type Description ValueError If x is passed, and does not have same number of rows as y. compute_conditional_dependence ( y , z , x = None ) Compute conditional dependence coefficient based on: Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics If X is passed, computes T(Y, Z|X) where T is the conditional dependence coefficient. Otherwise, computes T(Y, Z) . Conditional Dependence Coefficient lies between 0 and 1, and is 0 if Y is completely independent of Z|X 1 if Y is a measurable function of Z|X Parameters: Name Type Description Default y npt.ArrayLike A single list or 1D array or a pandas Series. required z npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None Returns: Type Description float Conditional Dependence Coefficient. Exceptions: Type Description ValueError If y is not 1d. ValueError If z is not 1d or 2d. ValueError If y and z have different lengths. ValueError If there are <= 2 valid y values. ValueError If x is passed, and not same number of rows as y. compute_conditional_dependence_1d ( y , z , x = None ) Computes conditional dependence of y on each column of z individually. Use when you want to compute T(Y, Z_j|X) for each column of Z. Parameters: Name Type Description Default y npt.ArrayLike A single list or 1D array or a pandas Series. required z npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None Returns: Type Description dict Keys are column names (or indices if x is not a pandas object), and values are conditional dependence coefficients. Exceptions: Type Description ValueError If y is not 1d. ValueError If z is not 1d or 2d. ValueError If y and z have different lengths. ValueError If there are <= 2 valid y values. ValueError If x is passed, and does not have the same number of rows as y.","title":"Conditional Dependence"},{"location":"codec_api/#workflow-module","text":"","title":"Workflow module"},{"location":"codec_api/#src.conditional_dependence.ConditionalDependence","text":"Class containing methods for calculating conditional dependence.","title":"ConditionalDependence"},{"location":"codec_api/#src.conditional_dependence.ConditionalDependence.__init__","text":"Initialize and Validate a ConditionalDependence object. You can then pass any X values to compute_conditional_dependence and compute_conditional_dependence_1d Parameters: Name Type Description Default y npt.ArrayLike A single list or 1D array or a pandas Series. required z npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required Exceptions: Type Description ValueError If y is not 1d. ValueError If z is not 1d or 2d. ValueError If y and z have different lengths. ValueError If there are <= 2 valid y values.","title":"__init__()"},{"location":"codec_api/#src.conditional_dependence.ConditionalDependence.compute_conditional_dependence","text":"Compute conditional dependence coefficient based on: Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics If X is passed, computes T(Y, Z|X) where T is the conditional dependence coefficient. Otherwise, computes T(Y, Z) . Conditional Dependence Coefficient lies between 0 and 1, and is 0 if Y is completely independent of Z|X 1 if Y is a measurable function of Z|X Parameters: Name Type Description Default x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None Returns: Type Description float Conditional Dependence Coefficient. Exceptions: Type Description ValueError If x is passed, and not same number of rows as y.","title":"compute_conditional_dependence()"},{"location":"codec_api/#src.conditional_dependence.ConditionalDependence.compute_conditional_dependence_1d","text":"Computes conditional dependence of y on each column of z individually. Use when you want to compute T(Y, Z_j|X) for each column of Z. Parameters: Name Type Description Default x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None Returns: Type Description dict Keys are column names (or indices if x is not a pandas object), and values are conditional dependence coefficients. Exceptions: Type Description ValueError If x is passed, and does not have same number of rows as y.","title":"compute_conditional_dependence_1d()"},{"location":"codec_api/#src.conditional_dependence.compute_conditional_dependence","text":"Compute conditional dependence coefficient based on: Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics If X is passed, computes T(Y, Z|X) where T is the conditional dependence coefficient. Otherwise, computes T(Y, Z) . Conditional Dependence Coefficient lies between 0 and 1, and is 0 if Y is completely independent of Z|X 1 if Y is a measurable function of Z|X Parameters: Name Type Description Default y npt.ArrayLike A single list or 1D array or a pandas Series. required z npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None Returns: Type Description float Conditional Dependence Coefficient. Exceptions: Type Description ValueError If y is not 1d. ValueError If z is not 1d or 2d. ValueError If y and z have different lengths. ValueError If there are <= 2 valid y values. ValueError If x is passed, and not same number of rows as y.","title":"compute_conditional_dependence()"},{"location":"codec_api/#src.conditional_dependence.compute_conditional_dependence_1d","text":"Computes conditional dependence of y on each column of z individually. Use when you want to compute T(Y, Z_j|X) for each column of Z. Parameters: Name Type Description Default y npt.ArrayLike A single list or 1D array or a pandas Series. required z npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None Returns: Type Description dict Keys are column names (or indices if x is not a pandas object), and values are conditional dependence coefficients. Exceptions: Type Description ValueError If y is not 1d. ValueError If z is not 1d or 2d. ValueError If y and z have different lengths. ValueError If there are <= 2 valid y values. ValueError If x is passed, and does not have the same number of rows as y.","title":"compute_conditional_dependence_1d()"},{"location":"foci/","text":"Feature Ordering by Conditional Dependence (FOCI) FOCI 1 is a forward stepwise feature selection algorithm for multivariate regression based on Conditional Dependence measure. Usage Make a random 2000x100 array of independent variables, and simulate a complex Y import numpy as np n = 2000 p = 100 x = np.random.normal(0, 1, (n, p)) y = x[:, 0] * x[:, 1] + np.sin(x[:, 2] * x[:, 0]) Select Features import xicorpy selected = xicorpy.select_features_using_foci(y, x, num_features=10) Select Features with Initial Feature Set import xicorpy selected = xicorpy.select_features_using_foci(y, x, num_features=10, init_selection=[0]) Citations Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics \u21a9","title":"FOCI"},{"location":"foci/#feature-ordering-by-conditional-dependence-foci","text":"FOCI 1 is a forward stepwise feature selection algorithm for multivariate regression based on Conditional Dependence measure.","title":"Feature Ordering by Conditional Dependence (FOCI)"},{"location":"foci/#usage","text":"Make a random 2000x100 array of independent variables, and simulate a complex Y import numpy as np n = 2000 p = 100 x = np.random.normal(0, 1, (n, p)) y = x[:, 0] * x[:, 1] + np.sin(x[:, 2] * x[:, 0]) Select Features import xicorpy selected = xicorpy.select_features_using_foci(y, x, num_features=10) Select Features with Initial Feature Set import xicorpy selected = xicorpy.select_features_using_foci(y, x, num_features=10, init_selection=[0])","title":"Usage"},{"location":"foci/#citations","text":"Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics \u21a9","title":"Citations"},{"location":"foci_api/","text":"FOCI module FOCI Class for computing FOCI. __init__ ( self , y , x ) special Initialize and validate the FOCI object. You can then use the select_features method to select features. Parameters: Name Type Description Default y npt.ArrayLike A single list or 1D array or a pandas Series. required x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required Exceptions: Type Description ValueError If y is not 1d. ValueError If x is not 1d or 2d. ValueError If y and x have different lengths. ValueError If there are <= 2 valid y values. select_features ( self , num_features = None , auto_stop = True , init_selection = None ) Selects features based on the Feature Ordering based on Conditional Independence (FOCI) algorithm in: Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics Parameters: Name Type Description Default num_features int Maximum number of features to select. Defaults to the number of features in x. None auto_stop bool Should the algorithm stop automatically when conditional dependence starts dropping? True init_selection list Initial selection of features. None Returns: Type Description list List of selected features. If x was pd.DataFrame , this will be column names. Otherwise, this will be indices. select_features_using_foci ( y , x , num_features = None , auto_stop = True , init_selection = None ) Implements the FOCI algorithm for feature selection. Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics. https://arxiv.org/abs/1910.12327. Parameters: Name Type Description Default y npt.ArrayLike The dependent variable. A single list or 1D array or a pandas Series. required x npt.ArrayLike The independent variables. A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required num_features int Max number of features to select. Defaults to ALL features. None auto_stop bool If True, stops when the conditional dependence stops increasing. True init_selection list Initial selection of features. If x is a pd.DataFrame , this is expected to be a list of column names. Otherwise, this is expected to be a list of indices. None Returns: Type Description list List of selected features. If x was pd.DataFrame , this will be column names. Otherwise, this will be indices. Exceptions: Type Description ValueError If y is not 1d. ValueError If x is not 1d or 2d. ValueError If y and x have different lengths. ValueError If there are <= 2 valid y values.","title":"FOCI"},{"location":"foci_api/#foci-module","text":"","title":"FOCI module"},{"location":"foci_api/#src.foci.FOCI","text":"Class for computing FOCI.","title":"FOCI"},{"location":"foci_api/#src.foci.FOCI.__init__","text":"Initialize and validate the FOCI object. You can then use the select_features method to select features. Parameters: Name Type Description Default y npt.ArrayLike A single list or 1D array or a pandas Series. required x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required Exceptions: Type Description ValueError If y is not 1d. ValueError If x is not 1d or 2d. ValueError If y and x have different lengths. ValueError If there are <= 2 valid y values.","title":"__init__()"},{"location":"foci_api/#src.foci.FOCI.select_features","text":"Selects features based on the Feature Ordering based on Conditional Independence (FOCI) algorithm in: Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics Parameters: Name Type Description Default num_features int Maximum number of features to select. Defaults to the number of features in x. None auto_stop bool Should the algorithm stop automatically when conditional dependence starts dropping? True init_selection list Initial selection of features. None Returns: Type Description list List of selected features. If x was pd.DataFrame , this will be column names. Otherwise, this will be indices.","title":"select_features()"},{"location":"foci_api/#src.foci.select_features_using_foci","text":"Implements the FOCI algorithm for feature selection. Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics. https://arxiv.org/abs/1910.12327. Parameters: Name Type Description Default y npt.ArrayLike The dependent variable. A single list or 1D array or a pandas Series. required x npt.ArrayLike The independent variables. A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required num_features int Max number of features to select. Defaults to ALL features. None auto_stop bool If True, stops when the conditional dependence stops increasing. True init_selection list Initial selection of features. If x is a pd.DataFrame , this is expected to be a list of column names. Otherwise, this is expected to be a list of indices. None Returns: Type Description list List of selected features. If x was pd.DataFrame , this will be column names. Otherwise, this will be indices. Exceptions: Type Description ValueError If y is not 1d. ValueError If x is not 1d or 2d. ValueError If y and x have different lengths. ValueError If there are <= 2 valid y values.","title":"select_features_using_foci()"},{"location":"xi/","text":"Chatterjee's Xi Coefficient Chatterjee's Xi 1 measures if Y is a function of X . The coefficient is 0 if X and Y are independent, and 1 if Y is a measurable function of X. Xi is computed by comparing ranks of consecutive values of X when Y is sorted. Lin and Han's 2 modification makes the original formulation more robust by comparing M right-neighbours. When M == 1, it reduces to the original formulation. Do note that this formulation is asymmetric : Xi(X, Y): Measures Y as a function of X Xi(Y, X): Measures X as a function of Y Xi(X, Y) != Xi(Y, X) To illustrate this better, consider the following example: X Y 8 6.58 8 5.76 8 7.71 8 8.84 8 8.47 8 7.04 8 5.25 19 12.5 8 5.56 8 7.91 8 6.89 This is the 4th dataset of Anscombe\u2019s quartet While we cannot have an estimate of Y given X, we can estimate X given Y - If Y < 10: X = 8, else X = 19 . Direction Chatterjee's Xi Modified Xi Xi(X, Y) 0.175 0.111 Xi(Y, X) 0.45 0.75 The above table also illustrates the impact of Lin and Han's modification. For very large data, the two are likely to be very similar, and for smaller data, Lin and Han's formulation tends to be appropriate. Usage import xicorpy x = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5] y = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68] xi = xicorpy.compute_xi_correlation(x, y) ## Get p-values: xi, p_value = xicorpy.compute_xi_correlation(x, y, get_p_values=True) ## Explicitly specify m-nearest-neighbours: xi = xicorpy.compute_xi_correlation(x, y, m_nearest_neighbours=5) ## Compute original formulation without Lin and Han's Modification: xi = xicorpy.compute_xi_correlation(x, y, get_modified_xi=False) Compute correlations between all columns in X vs all columns in Y: import pandas as pd import xicorpy x = pd.DataFrame({ \"x_1\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_2\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_3\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_4\": [8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8], }) y = pd.DataFrame({ \"y_1\": [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68], \"y_2\": [9.14, 8.14, 8.74, 8.77, 9.26, 8.1, 6.13, 3.1, 9.13, 7.26, 4.74], \"y_3\": [7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73], \"y_4\": [6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.5, 5.56, 7.91, 6.89], }) xi = xicorpy.compute_xi_correlation(x, y) Compute correlations between all columns in X: import pandas as pd import xicorpy x = pd.DataFrame({ \"x_1\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_2\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"y_1\": [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68], \"y_2\": [9.14, 8.14, 8.74, 8.77, 9.26, 8.1, 6.13, 3.1, 9.13, 7.26, 4.74], }) xi = xicorpy.compute_xi_correlation(x) Citations Chatterjee (2020). \"A new coefficient of correlation\" \u21a9 Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" \u21a9","title":"Chatterjee's Xi"},{"location":"xi/#chatterjees-xi-coefficient","text":"Chatterjee's Xi 1 measures if Y is a function of X . The coefficient is 0 if X and Y are independent, and 1 if Y is a measurable function of X. Xi is computed by comparing ranks of consecutive values of X when Y is sorted. Lin and Han's 2 modification makes the original formulation more robust by comparing M right-neighbours. When M == 1, it reduces to the original formulation. Do note that this formulation is asymmetric : Xi(X, Y): Measures Y as a function of X Xi(Y, X): Measures X as a function of Y Xi(X, Y) != Xi(Y, X) To illustrate this better, consider the following example: X Y 8 6.58 8 5.76 8 7.71 8 8.84 8 8.47 8 7.04 8 5.25 19 12.5 8 5.56 8 7.91 8 6.89 This is the 4th dataset of Anscombe\u2019s quartet While we cannot have an estimate of Y given X, we can estimate X given Y - If Y < 10: X = 8, else X = 19 . Direction Chatterjee's Xi Modified Xi Xi(X, Y) 0.175 0.111 Xi(Y, X) 0.45 0.75 The above table also illustrates the impact of Lin and Han's modification. For very large data, the two are likely to be very similar, and for smaller data, Lin and Han's formulation tends to be appropriate.","title":"Chatterjee's Xi Coefficient"},{"location":"xi/#usage","text":"import xicorpy x = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5] y = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68] xi = xicorpy.compute_xi_correlation(x, y) ## Get p-values: xi, p_value = xicorpy.compute_xi_correlation(x, y, get_p_values=True) ## Explicitly specify m-nearest-neighbours: xi = xicorpy.compute_xi_correlation(x, y, m_nearest_neighbours=5) ## Compute original formulation without Lin and Han's Modification: xi = xicorpy.compute_xi_correlation(x, y, get_modified_xi=False) Compute correlations between all columns in X vs all columns in Y: import pandas as pd import xicorpy x = pd.DataFrame({ \"x_1\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_2\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_3\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_4\": [8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8], }) y = pd.DataFrame({ \"y_1\": [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68], \"y_2\": [9.14, 8.14, 8.74, 8.77, 9.26, 8.1, 6.13, 3.1, 9.13, 7.26, 4.74], \"y_3\": [7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73], \"y_4\": [6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.5, 5.56, 7.91, 6.89], }) xi = xicorpy.compute_xi_correlation(x, y) Compute correlations between all columns in X: import pandas as pd import xicorpy x = pd.DataFrame({ \"x_1\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_2\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"y_1\": [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68], \"y_2\": [9.14, 8.14, 8.74, 8.77, 9.26, 8.1, 6.13, 3.1, 9.13, 7.26, 4.74], }) xi = xicorpy.compute_xi_correlation(x)","title":"Usage"},{"location":"xi/#citations","text":"Chatterjee (2020). \"A new coefficient of correlation\" \u21a9 Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" \u21a9","title":"Citations"},{"location":"xicor_api/","text":"Workflow module XiCorrelation Class containing Xi Correlation computation components __init__ ( self , x , y = None ) special If only x is passed, computes correlation between each column of x . If y is also passed, computes correlation between each column of x vs each column of y . If only x is passed, x MUST be 2-d. Otherwise, both x and y can be 1-d Parameters: Name Type Description Default x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required y npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None Exceptions: Type Description ValueError If x and y are not of the same shape. ValueError If there's less than 2 columns to compute correlation. compute_xi ( self , get_modified_xi = True , m_nearest_neighbours = None , get_p_values = False ) Compute the Xi Coefficient (Chatterjee's Rank Correlation) between columns in X and Y. Xi Coefficient based on: Chatterjee (2020). \"A new coefficient of correlation\" Modified Xi Coefficient based on: Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" The modified Xi Coefficient looks at M nearest neighbours to compute the correlation. This allows the coefficient to converge much faster. However, it is computationally slightly more intensive. For very large data, the two are likely to be very similar. We recommend using the modified Xi Coefficient. Parameters: Name Type Description Default get_modified_xi bool Should the modified xi be computed? True m_nearest_neighbours int Only used if get_modified_xi is True. None get_p_values bool Should the p-values be computed? The null hypothesis is that Y is completely independent of X (i.e., xi = 0). False Returns: Type Description float/np.ndarray/pd.DataFrame Xi Coefficient Values. If both X and Y are 1-d, returns a single float. If X is numpy object, returns a 2-D numpy array. Otherwise returns a pd.DataFrame. P-Values (only if get_p_values are true): Same format at Xi compute_xi_correlation ( x , y = None , get_modified_xi = True , m_nearest_neighbours = None , get_p_values = False ) Helper function to compute the Xi Coefficient - uses the class machinery from XiCorrelation . Compute the Xi Coefficient (Chatterjee's Rank Correlation) between columns in X and Y. Xi Coefficient based on: Chatterjee (2020). \"A new coefficient of correlation\" Modified Xi Coefficient based on: Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" The modified Xi Coefficient looks at M nearest neighbours to compute the correlation. This allows the coefficient to converge much faster. However, it is computationally slightly more intensive. For very large data, the two are likely to be very similar. We recommend using the modified Xi Coefficient. If only X is passed, computes correlation between each column of X. If Y is also passed, computes correlation between each column of X vs each column of Y. If only X is passed, X MUST be 2-d. Otherwise, both X and Y can be 1-d Parameters: Name Type Description Default x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required y npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None get_modified_xi bool Should the modified xi be computed? True m_nearest_neighbours int Only used if get_modified_xi is True. None get_p_values bool Should the p-values be computed? The null hypothesis is that Y is completely independent of X (i.e., xi = 0). False Returns: Type Description float/np.ndarray/pd.DataFrame Xi Coefficient Values. If both X and Y are 1-d, returns a single float. If X is numpy object, returns a 2-D numpy array. Otherwise returns a pd.DataFrame. P-Values (only if get_p_values are true): Same format at Xi","title":"XiCor"},{"location":"xicor_api/#workflow-module","text":"","title":"Workflow module"},{"location":"xicor_api/#src.correlation.XiCorrelation","text":"Class containing Xi Correlation computation components","title":"XiCorrelation"},{"location":"xicor_api/#src.correlation.XiCorrelation.__init__","text":"If only x is passed, computes correlation between each column of x . If y is also passed, computes correlation between each column of x vs each column of y . If only x is passed, x MUST be 2-d. Otherwise, both x and y can be 1-d Parameters: Name Type Description Default x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required y npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None Exceptions: Type Description ValueError If x and y are not of the same shape. ValueError If there's less than 2 columns to compute correlation.","title":"__init__()"},{"location":"xicor_api/#src.correlation.XiCorrelation.compute_xi","text":"Compute the Xi Coefficient (Chatterjee's Rank Correlation) between columns in X and Y. Xi Coefficient based on: Chatterjee (2020). \"A new coefficient of correlation\" Modified Xi Coefficient based on: Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" The modified Xi Coefficient looks at M nearest neighbours to compute the correlation. This allows the coefficient to converge much faster. However, it is computationally slightly more intensive. For very large data, the two are likely to be very similar. We recommend using the modified Xi Coefficient. Parameters: Name Type Description Default get_modified_xi bool Should the modified xi be computed? True m_nearest_neighbours int Only used if get_modified_xi is True. None get_p_values bool Should the p-values be computed? The null hypothesis is that Y is completely independent of X (i.e., xi = 0). False Returns: Type Description float/np.ndarray/pd.DataFrame Xi Coefficient Values. If both X and Y are 1-d, returns a single float. If X is numpy object, returns a 2-D numpy array. Otherwise returns a pd.DataFrame. P-Values (only if get_p_values are true): Same format at Xi","title":"compute_xi()"},{"location":"xicor_api/#src.correlation.compute_xi_correlation","text":"Helper function to compute the Xi Coefficient - uses the class machinery from XiCorrelation . Compute the Xi Coefficient (Chatterjee's Rank Correlation) between columns in X and Y. Xi Coefficient based on: Chatterjee (2020). \"A new coefficient of correlation\" Modified Xi Coefficient based on: Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" The modified Xi Coefficient looks at M nearest neighbours to compute the correlation. This allows the coefficient to converge much faster. However, it is computationally slightly more intensive. For very large data, the two are likely to be very similar. We recommend using the modified Xi Coefficient. If only X is passed, computes correlation between each column of X. If Y is also passed, computes correlation between each column of X vs each column of Y. If only X is passed, X MUST be 2-d. Otherwise, both X and Y can be 1-d Parameters: Name Type Description Default x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required y npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None get_modified_xi bool Should the modified xi be computed? True m_nearest_neighbours int Only used if get_modified_xi is True. None get_p_values bool Should the p-values be computed? The null hypothesis is that Y is completely independent of X (i.e., xi = 0). False Returns: Type Description float/np.ndarray/pd.DataFrame Xi Coefficient Values. If both X and Y are 1-d, returns a single float. If X is numpy object, returns a 2-D numpy array. Otherwise returns a pd.DataFrame. P-Values (only if get_p_values are true): Same format at Xi","title":"compute_xi_correlation()"}]}
{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Chatterjee's Xi, its Applications, and Offshoots","text":"<p>XicorPy is a Python package implementing Chatterjee's Xi, and its various offshoots.</p> <p>The package currently implements:   </p> <ol> <li>Chatterjee's Xi<sup>1</sup></li> <li>Modified Xi<sup>2</sup></li> <li>Conditional Dependence Coefficient<sup>3</sup></li> <li>Feature Selection via Feature Ordering by Conditional Independence (FOCI) Algorithm <sup>3</sup></li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>The package is available on PyPI. You can install using pip: <code>pip install xicorpy</code>.</p>"},{"location":"#usage","title":"Usage","text":"<p>Compute Chatterjee's Xi:</p> <pre><code>import xicorpy\n\nx = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5]\ny = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68]\nxi = xicorpy.compute_xi_correlation(x, y)\n\nxi, p_value = xicorpy.compute_xi_correlation(x, y, get_p_values=True)\n\n</code></pre> <p>Compute Conditional Dependence Coefficient:</p> <pre><code>import numpy as np\nimport xicorpy\n\nn = 10000\np = 3\nx = np.random.uniform(0, 1, (n, p))\n\n# y is independent of each x, but is a function of all three put together\ny = np.mod(x.sum(axis=1), 1)\n\n# y is independent of x, so coeff is 0. \nc = xicorpy.compute_conditional_dependence(y, x[:, 0])\nassert np.allclose(c, 0, atol=1e-2)\n\n# y is a function of all three put together. Now coeff is close to 1.\nc = xicorpy.compute_conditional_dependence(y, x)\nassert np.allclose(c, 1, atol=2e-1)\n\n# Given col1, and col2, y is a function of col3.\nc = xicorpy.compute_conditional_dependence(y, x[:, 0], x[:, 1:])\nassert np.allclose(c, 1, atol=1e-2)\n</code></pre> <p>Select Features using FOCI:</p> <pre><code>import numpy as np\nimport xicorpy\n\n\nn = 2000\np = 100\nx = np.random.normal(0, 1, (n, p))\ny = x[:, 0] * x[:, 1] + np.sin(x[:, 2] * x[:, 0])\n\n# Select Features\nselected = xicorpy.select_features_using_foci(y, x, num_features=10)\n\n# Select Features with Initial Feature Set\nselected = xicorpy.select_features_using_foci(y, x, num_features=10, init_selection=[0])\n</code></pre>"},{"location":"#citations","title":"Citations","text":"<ol> <li> <p>Chatterjee (2020). \"A new coefficient of correlation\" \u21a9</p> </li> <li> <p>Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" \u21a9</p> </li> <li> <p>Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\" \u21a9\u21a9</p> </li> </ol>"},{"location":"codec/","title":"Conditional Dependence Coefficient","text":"<p>Conditional Dependence Coefficient<sup>1</sup> measures if <code>Y is a function of Z|X</code> (represented at <code>T(Y, Z|X)</code>), where Z and X can both be multi-variate. When <code>X</code> is not present, it reduces to <code>T(Y, Z)</code>.</p> <p>The coefficient is computed by comparing the nearest neighbour of consecutive rows of Z when Y is sorted. It is 0 if <code>Y</code> is completely independent of <code>Z|X</code>, and 1 if <code>Y</code> is a measurable function of <code>Z|X</code>.</p>"},{"location":"codec/#usage","title":"Usage","text":"<p>Make a random 10000 x 3 array: </p> <p>Y is independent of each column. But it is a function of all three put together.</p> <pre><code>import numpy as np\n\nn = 10000\np = 3\nx = np.random.uniform(0, 1, (n, p))\n\n# y is independent of each x, but is a function of all three put together\ny = np.mod(x.sum(axis=1), 1)\n\n</code></pre> <p>Compute <code>T(Y, Z)</code>:</p> <pre><code>import xicorpy\n\n# y is independent of x, so coeff is 0. \nc = xicorpy.compute_conditional_dependence(y, x[:, 0])\nassert np.allclose(c, 0, atol=1e-2)\n\n# y is independent of any two x columns too, so coeff is again 0.\nc = xicorpy.compute_conditional_dependence(y, x[:, :1])\nassert np.allclose(c, 0, atol=1e-2)\nc = xicorpy.compute_conditional_dependence(y, x[:, 1:])\nassert np.allclose(c, 0, atol=1e-2)\n\n# y is a function of all three put together. Now coeff is close to 1.\nc = xicorpy.compute_conditional_dependence(y, x)\nassert np.allclose(c, 1, atol=1e-1)\n</code></pre> <p>Compute <code>T(Y, Z | X)</code>:</p> <pre><code># Given col1, and col2, y is a function of col3.\nc = xicorpy.compute_conditional_dependence(y, x[:, 0], x[:, 1:])\nassert np.allclose(c, 1, atol=1e-2)\n</code></pre> <p>Compute coefficient for each column of X:</p> <pre><code>c = xicorpy.compute_conditional_dependence_1d(y, x)\nassert isinstance(c, dict)\nassert sorted(c.keys()) == [0, 1, 2]\n\nc = xicorpy.compute_conditional_dependence_1d(y, x[:, :2], x[:, 2])\nassert isinstance(c, dict)\nassert sorted(c.keys()) == [0, 1]\n</code></pre>"},{"location":"codec/#citations","title":"Citations","text":"<ol> <li> <p>Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics \u21a9</p> </li> </ol>"},{"location":"codec_api/","title":"Workflow module","text":""},{"location":"codec_api/#xicorpy.conditional_dependence.ConditionalDependence","title":"<code>ConditionalDependence</code>","text":"<p>Class containing methods for calculating conditional dependence.</p> Source code in <code>xicorpy/conditional_dependence.py</code> <pre><code>class ConditionalDependence:\n    \"\"\"Class containing methods for calculating conditional dependence.\"\"\"\n\n    def __init__(self, y: npt.ArrayLike, z: npt.ArrayLike):\n        \"\"\"\n\n        Initialize and Validate a ConditionalDependence object.\n\n        You can then pass any X values to `compute_conditional_dependence` and `compute_conditional_dependence_1d`\n\n        Args:\n            y (npt.ArrayLike): A single list or 1D array or a pandas Series.\n            z (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n\n        Raises:\n            ValueError: If y is not 1d.\n            ValueError: If z is not 1d or 2d.\n            ValueError: If y and z have different lengths.\n            ValueError: If there are &lt;= 2 valid y values.\n        \"\"\"\n        self.y_, self.z_df = validate_and_prepare_for_conditional_dependence(y, z)\n        self.y = y\n        self.z = z\n\n    def _validate_x(self, x: npt.ArrayLike):\n        if not 1 &lt;= np.ndim(x) &lt;= 2:\n            raise ValueError(\"x must be a 1D or 2D array\")\n\n        x_shape = np.shape(x)\n        y_shape = np.shape(self.y)\n        if x_shape[0] != y_shape[0]:\n            raise ValueError(\"x must have the same number of samples as y\")\n\n    def compute_conditional_dependence(self, x: npt.ArrayLike = None):\n        \"\"\"\n        Compute conditional dependence coefficient based on:\n            [Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics](https://arxiv.org/abs/1910.12327)\n\n        If X is passed, computes `T(Y, Z|X)` where `T` is the conditional dependence coefficient. Otherwise, computes `T(Y, Z)`.\n\n        Conditional Dependence Coefficient lies between 0 and 1, and is\n\n            0 if Y is completely independent of Z|X\n            1 if Y is a measurable function of Z|X\n\n        Args:\n            x (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n\n        Returns:\n            float: Conditional Dependence Coefficient.\n\n        Raises:\n            ValueError: If x is passed, and not same number of rows as y.\n\n        \"\"\"\n        if x is None:\n            return _conditional_dependence_no_x(self.y_, self.z_df)\n        else:\n            self._validate_x(x)\n            x_ = convert_to_numeric(pd.DataFrame(x)).loc[self.y_.index]\n            return _conditional_dependence_with_x(self.y_, self.z_df, x_)\n\n    def compute_conditional_dependence_1d(self, x: npt.ArrayLike = None):\n        \"\"\"\n        Computes conditional dependence of y on **each column** of z individually.\n\n        Use when you want to compute `T(Y, Z_j|X)` for each column of Z.\n\n        Args:\n            x (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n\n        Returns:\n            dict: Keys are column names (or indices if x is not a pandas object), and values are conditional dependence coefficients.\n\n        Raises:\n            ValueError: If x is passed, and does not have same number of rows as y.\n\n        \"\"\"\n        if x is None:\n            return _conditional_dependence_each_z_no_x(self.y_, self.z_df)\n        else:\n            self._validate_x(x)\n            x_ = convert_to_numeric(pd.DataFrame(x)).loc[self.y_.index]\n            return _conditional_dependence_with_each_z(self.y_, self.z_df, x_)\n</code></pre>"},{"location":"codec_api/#xicorpy.conditional_dependence.ConditionalDependence.__init__","title":"<code>__init__(y, z)</code>","text":"<p>Initialize and Validate a ConditionalDependence object.</p> <p>You can then pass any X values to <code>compute_conditional_dependence</code> and <code>compute_conditional_dependence_1d</code></p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>npt.ArrayLike</code> <p>A single list or 1D array or a pandas Series.</p> required <code>z</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If y is not 1d.</p> <code>ValueError</code> <p>If z is not 1d or 2d.</p> <code>ValueError</code> <p>If y and z have different lengths.</p> <code>ValueError</code> <p>If there are &lt;= 2 valid y values.</p> Source code in <code>xicorpy/conditional_dependence.py</code> <pre><code>def __init__(self, y: npt.ArrayLike, z: npt.ArrayLike):\n    \"\"\"\n\n    Initialize and Validate a ConditionalDependence object.\n\n    You can then pass any X values to `compute_conditional_dependence` and `compute_conditional_dependence_1d`\n\n    Args:\n        y (npt.ArrayLike): A single list or 1D array or a pandas Series.\n        z (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n\n    Raises:\n        ValueError: If y is not 1d.\n        ValueError: If z is not 1d or 2d.\n        ValueError: If y and z have different lengths.\n        ValueError: If there are &lt;= 2 valid y values.\n    \"\"\"\n    self.y_, self.z_df = validate_and_prepare_for_conditional_dependence(y, z)\n    self.y = y\n    self.z = z\n</code></pre>"},{"location":"codec_api/#xicorpy.conditional_dependence.ConditionalDependence.compute_conditional_dependence","title":"<code>compute_conditional_dependence(x=None)</code>","text":"Compute conditional dependence coefficient based on <p>Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics</p> <p>If X is passed, computes <code>T(Y, Z|X)</code> where <code>T</code> is the conditional dependence coefficient. Otherwise, computes <code>T(Y, Z)</code>.</p> <p>Conditional Dependence Coefficient lies between 0 and 1, and is</p> <pre><code>0 if Y is completely independent of Z|X\n1 if Y is a measurable function of Z|X\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <p>Conditional Dependence Coefficient.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If x is passed, and not same number of rows as y.</p> Source code in <code>xicorpy/conditional_dependence.py</code> <pre><code>def compute_conditional_dependence(self, x: npt.ArrayLike = None):\n    \"\"\"\n    Compute conditional dependence coefficient based on:\n        [Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics](https://arxiv.org/abs/1910.12327)\n\n    If X is passed, computes `T(Y, Z|X)` where `T` is the conditional dependence coefficient. Otherwise, computes `T(Y, Z)`.\n\n    Conditional Dependence Coefficient lies between 0 and 1, and is\n\n        0 if Y is completely independent of Z|X\n        1 if Y is a measurable function of Z|X\n\n    Args:\n        x (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n\n    Returns:\n        float: Conditional Dependence Coefficient.\n\n    Raises:\n        ValueError: If x is passed, and not same number of rows as y.\n\n    \"\"\"\n    if x is None:\n        return _conditional_dependence_no_x(self.y_, self.z_df)\n    else:\n        self._validate_x(x)\n        x_ = convert_to_numeric(pd.DataFrame(x)).loc[self.y_.index]\n        return _conditional_dependence_with_x(self.y_, self.z_df, x_)\n</code></pre>"},{"location":"codec_api/#xicorpy.conditional_dependence.ConditionalDependence.compute_conditional_dependence_1d","title":"<code>compute_conditional_dependence_1d(x=None)</code>","text":"<p>Computes conditional dependence of y on each column of z individually.</p> <p>Use when you want to compute <code>T(Y, Z_j|X)</code> for each column of Z.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Keys are column names (or indices if x is not a pandas object), and values are conditional dependence coefficients.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If x is passed, and does not have same number of rows as y.</p> Source code in <code>xicorpy/conditional_dependence.py</code> <pre><code>def compute_conditional_dependence_1d(self, x: npt.ArrayLike = None):\n    \"\"\"\n    Computes conditional dependence of y on **each column** of z individually.\n\n    Use when you want to compute `T(Y, Z_j|X)` for each column of Z.\n\n    Args:\n        x (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n\n    Returns:\n        dict: Keys are column names (or indices if x is not a pandas object), and values are conditional dependence coefficients.\n\n    Raises:\n        ValueError: If x is passed, and does not have same number of rows as y.\n\n    \"\"\"\n    if x is None:\n        return _conditional_dependence_each_z_no_x(self.y_, self.z_df)\n    else:\n        self._validate_x(x)\n        x_ = convert_to_numeric(pd.DataFrame(x)).loc[self.y_.index]\n        return _conditional_dependence_with_each_z(self.y_, self.z_df, x_)\n</code></pre>"},{"location":"codec_api/#xicorpy.conditional_dependence.compute_conditional_dependence","title":"<code>compute_conditional_dependence(y, z, x=None)</code>","text":"Compute conditional dependence coefficient based on <p>Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics</p> <p>If X is passed, computes <code>T(Y, Z|X)</code> where <code>T</code> is the conditional dependence coefficient. Otherwise, computes <code>T(Y, Z)</code>.</p> <p>Conditional Dependence Coefficient lies between 0 and 1, and is</p> <pre><code>0 if Y is completely independent of Z|X\n1 if Y is a measurable function of Z|X\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>npt.ArrayLike</code> <p>A single list or 1D array or a pandas Series.</p> required <code>z</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> required <code>x</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Conditional Dependence Coefficient.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If y is not 1d.</p> <code>ValueError</code> <p>If z is not 1d or 2d.</p> <code>ValueError</code> <p>If y and z have different lengths.</p> <code>ValueError</code> <p>If there are &lt;= 2 valid y values.</p> <code>ValueError</code> <p>If x is passed, and not same number of rows as y.</p> Source code in <code>xicorpy/conditional_dependence.py</code> <pre><code>def compute_conditional_dependence(\n    y: npt.ArrayLike, z: npt.ArrayLike, x: npt.ArrayLike = None\n) -&gt; float:\n    \"\"\"\n    Compute conditional dependence coefficient based on:\n        [Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics](https://arxiv.org/abs/1910.12327)\n\n    If X is passed, computes `T(Y, Z|X)` where `T` is the conditional dependence coefficient. Otherwise, computes `T(Y, Z)`.\n\n    Conditional Dependence Coefficient lies between 0 and 1, and is\n\n        0 if Y is completely independent of Z|X\n        1 if Y is a measurable function of Z|X\n\n    Args:\n        y (npt.ArrayLike): A single list or 1D array or a pandas Series.\n        z (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n        x (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n\n    Returns:\n        float: Conditional Dependence Coefficient.\n\n    Raises:\n        ValueError: If y is not 1d.\n        ValueError: If z is not 1d or 2d.\n        ValueError: If y and z have different lengths.\n        ValueError: If there are &lt;= 2 valid y values.\n        ValueError: If x is passed, and not same number of rows as y.\n\n    \"\"\"\n    return ConditionalDependence(y, z).compute_conditional_dependence(x)\n</code></pre>"},{"location":"codec_api/#xicorpy.conditional_dependence.compute_conditional_dependence_1d","title":"<code>compute_conditional_dependence_1d(y, z, x=None)</code>","text":"<p>Computes conditional dependence of y on each column of z individually.</p> <p>Use when you want to compute <code>T(Y, Z_j|X)</code> for each column of Z.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>npt.ArrayLike</code> <p>A single list or 1D array or a pandas Series.</p> required <code>z</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> required <code>x</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>Dict[Union[str, int], float]</code> <p>Keys are column names (or indices if x is not a pandas object), and values are conditional dependence coefficients.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If y is not 1d.</p> <code>ValueError</code> <p>If z is not 1d or 2d.</p> <code>ValueError</code> <p>If y and z have different lengths.</p> <code>ValueError</code> <p>If there are &lt;= 2 valid y values.</p> <code>ValueError</code> <p>If x is passed, and does not have the same number of rows as y.</p> Source code in <code>xicorpy/conditional_dependence.py</code> <pre><code>def compute_conditional_dependence_1d(\n    y: npt.ArrayLike, z: npt.ArrayLike, x: npt.ArrayLike = None\n) -&gt; Dict[Union[str, int], float]:\n    \"\"\"\n    Computes conditional dependence of y on **each column** of z individually.\n\n    Use when you want to compute `T(Y, Z_j|X)` for each column of Z.\n\n    Args:\n        y (npt.ArrayLike): A single list or 1D array or a pandas Series.\n        z (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n        x (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n\n    Returns:\n        dict: Keys are column names (or indices if x is not a pandas object), and values are conditional dependence coefficients.\n\n    Raises:\n        ValueError: If y is not 1d.\n        ValueError: If z is not 1d or 2d.\n        ValueError: If y and z have different lengths.\n        ValueError: If there are &lt;= 2 valid y values.\n        ValueError: If x is passed, and does not have the same number of rows as y.\n\n    \"\"\"\n    return ConditionalDependence(y, z).compute_conditional_dependence_1d(x)\n</code></pre>"},{"location":"foci/","title":"Feature Ordering by Conditional Dependence (FOCI)","text":"<p>FOCI<sup>1</sup> is a forward stepwise feature selection algorithm  for multivariate regression based on Conditional Dependence measure.</p>"},{"location":"foci/#usage","title":"Usage","text":"<p>Make a random <code>2000x100</code> array of independent variables, and simulate a complex <code>Y</code></p> <pre><code>import numpy as np\n\n\nn = 2000\np = 100\nx = np.random.normal(0, 1, (n, p))\ny = x[:, 0] * x[:, 1] + np.sin(x[:, 2] * x[:, 0])\n</code></pre> <p>Select Features</p> <pre><code>import xicorpy\n\nselected = xicorpy.select_features_using_foci(y, x, num_features=10)\n</code></pre> <p>Select Features with Initial Feature Set</p> <pre><code>import xicorpy\n\nselected = xicorpy.select_features_using_foci(y, x, num_features=10, init_selection=[0])\n</code></pre>"},{"location":"foci/#citations","title":"Citations","text":"<ol> <li> <p>Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics \u21a9</p> </li> </ol>"},{"location":"foci_api/","title":"FOCI module","text":""},{"location":"foci_api/#xicorpy.foci.FOCI","title":"<code>FOCI</code>","text":"<p>Class for computing FOCI.</p> Source code in <code>xicorpy/foci.py</code> <pre><code>class FOCI:\n    \"\"\"Class for computing FOCI.\"\"\"\n\n    def __init__(self, y: npt.ArrayLike, x: npt.ArrayLike):\n        \"\"\"\n        Initialize and validate the FOCI object.\n\n        You can then use the `select_features` method to select features.\n\n        Args:\n            y (npt.ArrayLike): A single list or 1D array or a pandas Series.\n            x (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n\n        Raises:\n            ValueError: If y is not 1d.\n            ValueError: If x is not 1d or 2d.\n            ValueError: If y and x have different lengths.\n            ValueError: If there are &lt;= 2 valid y values.\n        \"\"\"\n        self.y_, self.x_df = validate_and_prepare_for_conditional_dependence(y, x)\n\n    def _get_next_p(self, current_selection: List[Union[int, str]]):\n        if current_selection:\n            to_be_evaluated = [k for k in self.x_df if k not in current_selection]\n            codec = compute_conditional_dependence_1d(\n                self.y_, self.x_df[to_be_evaluated], self.x_df[current_selection]\n            )\n        else:\n            codec = compute_conditional_dependence_1d(self.y_, self.x_df)\n\n        if not codec:\n            return 0, 0 # pragma: no cover\n        next_p = max(codec, key=lambda k: codec[k])\n        return next_p, codec[next_p]\n\n    def select_features(\n        self,\n        num_features: int = None,\n        init_selection: List[Union[int, str]] = None,\n        get_conditional_dependency: bool = False,\n    ) -&gt; Union[List[Union[int, str]], Tuple[List[Union[int, str]], List[float]]]:\n        \"\"\"\n        Selects features based on the Feature Ordering based on Conditional Independence (FOCI) algorithm in:\n            [Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics](https://arxiv.org/abs/1910.12327)\n\n        Args:\n            num_features: Maximum number of features to select. Defaults to the number of features in x.\n            init_selection (list): Initial selection of features.\n            get_conditional_dependency (bool): If True, returns conditional dependency. Defaults to False\n\n        Returns:\n            list: List of selected features.\n                If x was `pd.DataFrame`, this will be column names.\n                Otherwise, this will be indices.\n            list: Conditional Dependency measure as each feature got selected\n                Only when get_conditional_dependency is True\n\n        \"\"\"\n        if num_features is None:  # pragma: no cover\n            num_features = self.x_df.shape[1]\n\n        current_selection = [i for i in (init_selection or [])]\n        if len(current_selection) &gt;= num_features:\n            warnings.warn(\"Initial selection is already complete\")\n            if get_conditional_dependency:  # pragma: no cover\n                return current_selection, []\n            return current_selection\n\n        codec = []\n        stop = False\n        while not stop and len(current_selection) &lt; num_features:\n            next_p, next_t = self._get_next_p(current_selection)\n\n            if next_t &lt;= 0:  # pragma: no cover\n                stop = True\n            else:\n                current_selection.append(next_p)\n                if get_conditional_dependency:\n                    codec.append(\n                        compute_conditional_dependence(\n                            self.y_, self.x_df[current_selection]\n                        )\n                    )\n\n        if get_conditional_dependency:\n            return current_selection, codec\n\n        return current_selection\n</code></pre>"},{"location":"foci_api/#xicorpy.foci.FOCI.__init__","title":"<code>__init__(y, x)</code>","text":"<p>Initialize and validate the FOCI object.</p> <p>You can then use the <code>select_features</code> method to select features.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>npt.ArrayLike</code> <p>A single list or 1D array or a pandas Series.</p> required <code>x</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If y is not 1d.</p> <code>ValueError</code> <p>If x is not 1d or 2d.</p> <code>ValueError</code> <p>If y and x have different lengths.</p> <code>ValueError</code> <p>If there are &lt;= 2 valid y values.</p> Source code in <code>xicorpy/foci.py</code> <pre><code>def __init__(self, y: npt.ArrayLike, x: npt.ArrayLike):\n    \"\"\"\n    Initialize and validate the FOCI object.\n\n    You can then use the `select_features` method to select features.\n\n    Args:\n        y (npt.ArrayLike): A single list or 1D array or a pandas Series.\n        x (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n\n    Raises:\n        ValueError: If y is not 1d.\n        ValueError: If x is not 1d or 2d.\n        ValueError: If y and x have different lengths.\n        ValueError: If there are &lt;= 2 valid y values.\n    \"\"\"\n    self.y_, self.x_df = validate_and_prepare_for_conditional_dependence(y, x)\n</code></pre>"},{"location":"foci_api/#xicorpy.foci.FOCI.select_features","title":"<code>select_features(num_features=None, init_selection=None, get_conditional_dependency=False)</code>","text":"<p>Selects features based on the Feature Ordering based on Conditional Independence (FOCI) algorithm in:     Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics</p> <p>Parameters:</p> Name Type Description Default <code>num_features</code> <code>int</code> <p>Maximum number of features to select. Defaults to the number of features in x.</p> <code>None</code> <code>init_selection</code> <code>list</code> <p>Initial selection of features.</p> <code>None</code> <code>get_conditional_dependency</code> <code>bool</code> <p>If True, returns conditional dependency. Defaults to False</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>Union[List[Union[int, str]], Tuple[List[Union[int, str]], List[float]]]</code> <p>List of selected features. If x was <code>pd.DataFrame</code>, this will be column names. Otherwise, this will be indices.</p> <code>list</code> <code>Union[List[Union[int, str]], Tuple[List[Union[int, str]], List[float]]]</code> <p>Conditional Dependency measure as each feature got selected Only when get_conditional_dependency is True</p> Source code in <code>xicorpy/foci.py</code> <pre><code>def select_features(\n    self,\n    num_features: int = None,\n    init_selection: List[Union[int, str]] = None,\n    get_conditional_dependency: bool = False,\n) -&gt; Union[List[Union[int, str]], Tuple[List[Union[int, str]], List[float]]]:\n    \"\"\"\n    Selects features based on the Feature Ordering based on Conditional Independence (FOCI) algorithm in:\n        [Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics](https://arxiv.org/abs/1910.12327)\n\n    Args:\n        num_features: Maximum number of features to select. Defaults to the number of features in x.\n        init_selection (list): Initial selection of features.\n        get_conditional_dependency (bool): If True, returns conditional dependency. Defaults to False\n\n    Returns:\n        list: List of selected features.\n            If x was `pd.DataFrame`, this will be column names.\n            Otherwise, this will be indices.\n        list: Conditional Dependency measure as each feature got selected\n            Only when get_conditional_dependency is True\n\n    \"\"\"\n    if num_features is None:  # pragma: no cover\n        num_features = self.x_df.shape[1]\n\n    current_selection = [i for i in (init_selection or [])]\n    if len(current_selection) &gt;= num_features:\n        warnings.warn(\"Initial selection is already complete\")\n        if get_conditional_dependency:  # pragma: no cover\n            return current_selection, []\n        return current_selection\n\n    codec = []\n    stop = False\n    while not stop and len(current_selection) &lt; num_features:\n        next_p, next_t = self._get_next_p(current_selection)\n\n        if next_t &lt;= 0:  # pragma: no cover\n            stop = True\n        else:\n            current_selection.append(next_p)\n            if get_conditional_dependency:\n                codec.append(\n                    compute_conditional_dependence(\n                        self.y_, self.x_df[current_selection]\n                    )\n                )\n\n    if get_conditional_dependency:\n        return current_selection, codec\n\n    return current_selection\n</code></pre>"},{"location":"foci_api/#xicorpy.foci.select_features_using_foci","title":"<code>select_features_using_foci(y, x, num_features=None, init_selection=None, get_conditional_dependency=False)</code>","text":"<p>Implements the FOCI algorithm for feature selection.</p> <p>Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics. https://arxiv.org/abs/1910.12327.</p> <p>Parameters:</p> Name Type Description Default <code>y</code> <code>npt.ArrayLike</code> <p>The dependent variable. A single list or 1D array or a pandas Series.</p> required <code>x</code> <code>npt.ArrayLike</code> <p>The independent variables. A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> required <code>num_features</code> <code>int</code> <p>Max number of features to select. Defaults to ALL features.</p> <code>None</code> <code>init_selection</code> <code>list</code> <p>Initial selection of features. If <code>x</code> is a <code>pd.DataFrame</code>, this is expected to be a list of column names. Otherwise, this is expected to be a list of indices.</p> <code>None</code> <code>get_conditional_dependency</code> <code>bool</code> <p>If True, returns conditional dependency</p> <code>False</code> <p>Returns:</p> Name Type Description <code>list</code> <code>Union[List[Union[int, str]], Tuple[List[Union[int, str]], List[float]]]</code> <p>List of selected features. If x was <code>pd.DataFrame</code>, this will be column names. Otherwise, this will be indices.</p> <code>list</code> <code>Union[List[Union[int, str]], Tuple[List[Union[int, str]], List[float]]]</code> <p>Conditional Dependency measure as each feature got selected Only when get_conditional_dependency is True</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If y is not 1d.</p> <code>ValueError</code> <p>If x is not 1d or 2d.</p> <code>ValueError</code> <p>If y and x have different lengths.</p> <code>ValueError</code> <p>If there are &lt;= 2 valid y values.</p> Source code in <code>xicorpy/foci.py</code> <pre><code>def select_features_using_foci(\n    y: npt.ArrayLike,\n    x: npt.ArrayLike,\n    num_features: int = None,\n    init_selection: List[Union[int, str]] = None,\n    get_conditional_dependency: bool = False,\n) -&gt; Union[List[Union[int, str]], Tuple[List[Union[int, str]], List[float]]]:\n    \"\"\"\n    Implements the FOCI algorithm for feature selection.\n\n    Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\", Annals of Statistics.\n    https://arxiv.org/abs/1910.12327.\n\n    Args:\n        y (npt.ArrayLike): The dependent variable. A single list or 1D array or a pandas Series.\n        x (npt.ArrayLike): The independent variables. A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n        num_features: Max number of features to select. Defaults to ALL features.\n        init_selection (list): Initial selection of features.\n            If `x` is a `pd.DataFrame`, this is expected to be a list of column names.\n            Otherwise, this is expected to be a list of indices.\n        get_conditional_dependency (bool): If True, returns conditional dependency\n\n    Returns:\n        list: List of selected features.\n            If x was `pd.DataFrame`, this will be column names.\n            Otherwise, this will be indices.\n        list: Conditional Dependency measure as each feature got selected\n            Only when get_conditional_dependency is True\n\n    Raises:\n        ValueError: If y is not 1d.\n        ValueError: If x is not 1d or 2d.\n        ValueError: If y and x have different lengths.\n        ValueError: If there are &lt;= 2 valid y values.\n\n    \"\"\"\n    return FOCI(y, x).select_features(\n        num_features,\n        init_selection,\n        get_conditional_dependency=get_conditional_dependency,\n    )\n</code></pre>"},{"location":"xi/","title":"Chatterjee's Xi Coefficient","text":"<p>Chatterjee's Xi<sup>1</sup> measures if <code>Y is a function of X</code>.  The coefficient is 0 if X and Y are independent, and 1 if Y is a measurable function of X.  Xi is computed by comparing ranks of consecutive values of X when Y is sorted. </p> <p>Lin and Han's <sup>2</sup> modification makes the original formulation more robust by comparing M right-neighbours.  When M == 1, it reduces to the original formulation.</p> <p>Do note that this formulation is <code>asymmetric</code>:</p> <pre><code>Xi(X, Y): Measures Y as a function of X\nXi(Y, X): Measures X as a function of Y \n\nXi(X, Y) != Xi(Y, X)\n</code></pre> <p>To illustrate this better, consider the following example:</p> X Y 8 6.58 8 5.76 8 7.71 8 8.84 8 8.47 8 7.04 8 5.25 19 12.5 8 5.56 8 7.91 8 6.89 <p>This is the 4th dataset of Anscombe\u2019s quartet</p> <p>While we cannot have an estimate of Y given X, we can estimate X given Y - <code>If Y &lt; 10: X = 8, else X = 19</code>.</p> Direction Chatterjee's Xi Modified Xi Xi(X, Y) 0.175 0.111 Xi(Y, X) 0.45 0.75 <p>The above table also illustrates the impact of Lin and Han's modification.  For very large data, the two are likely to be very similar, and for smaller data, Lin and Han's formulation tends to be appropriate.</p>"},{"location":"xi/#usage","title":"Usage","text":"<pre><code>import xicorpy\n\nx = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5]\ny = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68]\nxi = xicorpy.compute_xi_correlation(x, y)\n\n## Get p-values:\nxi, p_value = xicorpy.compute_xi_correlation(x, y, get_p_values=True)\n\n## Explicitly specify m-nearest-neighbours:\nxi = xicorpy.compute_xi_correlation(x, y, m_nearest_neighbours=5)\n\n## Compute original formulation without Lin and Han's Modification:\nxi = xicorpy.compute_xi_correlation(x, y, get_modified_xi=False)\n\n</code></pre> <p>Compute correlations between all columns in X vs all columns in Y:</p> <pre><code>\nimport pandas as pd\nimport xicorpy\n\nx = pd.DataFrame({\n    \"x_1\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5],\n    \"x_2\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5],\n    \"x_3\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5],\n    \"x_4\": [8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8],\n})\ny = pd.DataFrame({\n    \"y_1\": [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68],\n    \"y_2\": [9.14, 8.14, 8.74, 8.77, 9.26, 8.1, 6.13, 3.1, 9.13, 7.26, 4.74],\n    \"y_3\": [7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73],\n    \"y_4\": [6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.5, 5.56, 7.91, 6.89],\n})\n\nxi = xicorpy.compute_xi_correlation(x, y)\n</code></pre> <p>Compute correlations between all columns in X:</p> <pre><code>\nimport pandas as pd\nimport xicorpy\n\nx = pd.DataFrame({\n    \"x_1\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5],\n    \"x_2\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5],\n    \"y_1\": [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68],\n    \"y_2\": [9.14, 8.14, 8.74, 8.77, 9.26, 8.1, 6.13, 3.1, 9.13, 7.26, 4.74],\n})\n\nxi = xicorpy.compute_xi_correlation(x)\n</code></pre>"},{"location":"xi/#citations","title":"Citations","text":"<ol> <li> <p>Chatterjee (2020). \"A new coefficient of correlation\" \u21a9</p> </li> <li> <p>Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" \u21a9</p> </li> </ol>"},{"location":"xicor_api/","title":"Workflow module","text":""},{"location":"xicor_api/#xicorpy.correlation.XiCorrelation","title":"<code>XiCorrelation</code>","text":"<p>Class containing Xi Correlation computation components</p> Source code in <code>xicorpy/correlation.py</code> <pre><code>class XiCorrelation:\n    \"\"\"Class containing Xi Correlation computation components\"\"\"\n\n    def __init__(self, x: npt.ArrayLike, y: npt.ArrayLike = None):\n        \"\"\"\n        If only `x` is passed, computes correlation between each column of `x`.\n        If `y` is also passed, computes correlation between each column of `x` vs each column of `y`.\n\n        If only `x` is passed, `x` MUST be 2-d. Otherwise, both `x` and `y` can be 1-d\n\n        Args:\n            x (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n            y (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n\n        Raises:\n            ValueError: If x and y are not of the same shape.\n            ValueError: If there's less than 2 columns to compute correlation.\n\n        \"\"\"\n        if not (1 &lt;= np.ndim(x) &lt;= 2 and np.shape(x)[0] &gt;= 1):\n            raise ValueError(\"x must be a 1D/2D array/list\")\n\n        x_df = pd.DataFrame(x)\n        x_shape = np.shape(x)\n\n        if y is not None:\n            if not (1 &lt;= np.ndim(y) &lt;= 2 and np.shape(y)[0] &gt;= 1):\n                raise ValueError(\"y must be a 1D/2D array/list\")\n            y_shape = np.shape(y)\n            if x_shape[0] != y_shape[0]:\n                raise ValueError(\n                    f\"x: {x_shape[0]} samples, y: {y_shape[0]} samples. \"\n                    f\"x and y MUST HAVE the same number of samples\"\n                )\n            y_df = pd.DataFrame(y)\n        else:\n            if not (np.ndim(x) == 2 and np.shape(x)[0] &gt;= 2 and np.shape(x)[1] &gt;= 2):\n                raise ValueError(\"x must be 2D if y is not provided\")\n            y_df = pd.DataFrame(x)\n\n        self.x_df = convert_to_numeric(x_df)\n        self.y_df = convert_to_numeric(y_df)\n\n        self._x = x\n        self._y = y\n\n    def compute_xi(\n        self,\n        get_modified_xi: bool = None,\n        m_nearest_neighbours: int = None,\n        get_p_values: bool = False,\n    ) -&gt; Union[_RetType, Tuple[_RetType, _RetType]]:\n        \"\"\"\n        Compute the Xi Coefficient (Chatterjee's Rank Correlation) between columns in X and Y.\n\n        Xi Coefficient based on:\n            [Chatterjee (2020). \"A new coefficient of correlation\"](https://arxiv.org/abs/1909.10140)\n\n\n        Modified Xi Coefficient based on:\n            [Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\"](https://arxiv.org/abs/2108.06828)\n\n        The modified Xi Coefficient looks at M nearest neighbours to compute the correlation.\n        This allows the coefficient to converge much faster. However, it is computationally slightly more intensive.\n        For very large data, the two are likely to be very similar. We recommend using the modified Xi Coefficient.\n\n        Args:\n            get_modified_xi: Should the modified xi be computed?\n                    Defaults to True when there are no ties, and False when ties are present.\n            m_nearest_neighbours: Only used when get_modified_xi is True.\n                    Defaults to square-root of array size.\n            get_p_values: Should the p-values be computed?\n                    The null hypothesis is that Y is completely independent of X (i.e., xi = 0).\n\n        Returns:\n            float/np.ndarray/pd.DataFrame:\n            - Xi Coefficient Values.\n                - If both X and Y are 1-d, returns a single float.\n                - If X is numpy object, returns a 2-D numpy array.\n                - Otherwise returns a pd.DataFrame.\n            - P-Values (only when get_p_values are true):\n                - Same format at Xi\n\n        \"\"\"\n        if get_modified_xi is False:\n            pass\n        else:\n            ties = _check_ties(self.x_df, self.y_df)\n            if ties:\n                if get_modified_xi is True:\n                    warnings.warn(\n                        \"Cannot use modified xi when there are ties present. Either explicitly set\"\n                        \"`get_modified_xi=False` or leave as `None` to accept automatic decision.\",\n                        RuntimeWarning,\n                    )\n                else:\n                    get_modified_xi = False\n            elif get_modified_xi is None:\n                get_modified_xi = True\n\n        ret = pd.DataFrame(0.0, index=self.x_df.columns, columns=self.y_df.columns)\n        _, p = _get_p_no_ties(0, self.x_df.shape[0])\n        p_values = pd.DataFrame(p, index=self.x_df.columns, columns=self.y_df.columns)\n\n        for i in self.x_df.columns:\n            i_col: pd.Series = self.x_df[i]\n            if i_col.min() == i_col.max():  # pragma: no cover\n                # Constant column. Correlation will anyway be 0.\n                ret.loc[i] = 0\n            else:\n                if i_col.hasnans:\n                    i_col = i_col.dropna()\n\n                if i_col.shape[0] &lt;= 2:  # pragma: no cover\n                    # Not enough samples to compute correlation.\n                    ret.loc[i] = 0\n                else:\n                    # Sort once to avoid sorting each time we compute correlation.\n                    i_col = i_col.sort_values(kind=\"stable\")\n                    for j in self.y_df.columns:\n                        j_col: pd.Series = self.y_df.loc[i_col.index, j]\n                        if j_col.hasnans:\n                            j_col = j_col.dropna()\n\n                        if get_p_values:\n                            xi, sd, p = _single_pair(  # type: ignore\n                                i_col,\n                                j_col,\n                                get_modified_xi,\n                                m_nearest_neighbours,\n                                True,\n                            )\n                            ret.loc[i, j] = xi\n                            p_values.loc[i, j] = p\n                        else:\n                            ret.loc[i, j] = _single_pair(\n                                i_col,\n                                j_col,\n                                get_modified_xi,\n                                m_nearest_neighbours,\n                                False,\n                            )\n\n        if (\n            isinstance(self._x, list)\n            and isinstance(self._y, list)\n            and np.ndim(self._x) == 1\n            and np.ndim(self._y) == 1\n        ):\n            if get_p_values:\n                return ret.values[0, 0], p_values.values[0, 0]\n            else:\n                return ret.values[0, 0]\n\n        if isinstance(self._x, np.ndarray):\n            ret = ret.values\n            p_values = p_values.values\n\n        if get_p_values:\n            return ret, p_values\n\n        return ret\n</code></pre>"},{"location":"xicor_api/#xicorpy.correlation.XiCorrelation.__init__","title":"<code>__init__(x, y=None)</code>","text":"<p>If only <code>x</code> is passed, computes correlation between each column of <code>x</code>. If <code>y</code> is also passed, computes correlation between each column of <code>x</code> vs each column of <code>y</code>.</p> <p>If only <code>x</code> is passed, <code>x</code> MUST be 2-d. Otherwise, both <code>x</code> and <code>y</code> can be 1-d</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> required <code>y</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If x and y are not of the same shape.</p> <code>ValueError</code> <p>If there's less than 2 columns to compute correlation.</p> Source code in <code>xicorpy/correlation.py</code> <pre><code>def __init__(self, x: npt.ArrayLike, y: npt.ArrayLike = None):\n    \"\"\"\n    If only `x` is passed, computes correlation between each column of `x`.\n    If `y` is also passed, computes correlation between each column of `x` vs each column of `y`.\n\n    If only `x` is passed, `x` MUST be 2-d. Otherwise, both `x` and `y` can be 1-d\n\n    Args:\n        x (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n        y (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n\n    Raises:\n        ValueError: If x and y are not of the same shape.\n        ValueError: If there's less than 2 columns to compute correlation.\n\n    \"\"\"\n    if not (1 &lt;= np.ndim(x) &lt;= 2 and np.shape(x)[0] &gt;= 1):\n        raise ValueError(\"x must be a 1D/2D array/list\")\n\n    x_df = pd.DataFrame(x)\n    x_shape = np.shape(x)\n\n    if y is not None:\n        if not (1 &lt;= np.ndim(y) &lt;= 2 and np.shape(y)[0] &gt;= 1):\n            raise ValueError(\"y must be a 1D/2D array/list\")\n        y_shape = np.shape(y)\n        if x_shape[0] != y_shape[0]:\n            raise ValueError(\n                f\"x: {x_shape[0]} samples, y: {y_shape[0]} samples. \"\n                f\"x and y MUST HAVE the same number of samples\"\n            )\n        y_df = pd.DataFrame(y)\n    else:\n        if not (np.ndim(x) == 2 and np.shape(x)[0] &gt;= 2 and np.shape(x)[1] &gt;= 2):\n            raise ValueError(\"x must be 2D if y is not provided\")\n        y_df = pd.DataFrame(x)\n\n    self.x_df = convert_to_numeric(x_df)\n    self.y_df = convert_to_numeric(y_df)\n\n    self._x = x\n    self._y = y\n</code></pre>"},{"location":"xicor_api/#xicorpy.correlation.XiCorrelation.compute_xi","title":"<code>compute_xi(get_modified_xi=None, m_nearest_neighbours=None, get_p_values=False)</code>","text":"<p>Compute the Xi Coefficient (Chatterjee's Rank Correlation) between columns in X and Y.</p> Xi Coefficient based on <p>Chatterjee (2020). \"A new coefficient of correlation\"</p> Modified Xi Coefficient based on <p>Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\"</p> <p>The modified Xi Coefficient looks at M nearest neighbours to compute the correlation. This allows the coefficient to converge much faster. However, it is computationally slightly more intensive. For very large data, the two are likely to be very similar. We recommend using the modified Xi Coefficient.</p> <p>Parameters:</p> Name Type Description Default <code>get_modified_xi</code> <code>bool</code> <p>Should the modified xi be computed?     Defaults to True when there are no ties, and False when ties are present.</p> <code>None</code> <code>m_nearest_neighbours</code> <code>int</code> <p>Only used when get_modified_xi is True.     Defaults to square-root of array size.</p> <code>None</code> <code>get_p_values</code> <code>bool</code> <p>Should the p-values be computed?     The null hypothesis is that Y is completely independent of X (i.e., xi = 0).</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[_RetType, Tuple[_RetType, _RetType]]</code> <p>float/np.ndarray/pd.DataFrame:</p> <code>Union[_RetType, Tuple[_RetType, _RetType]]</code> <ul> <li>Xi Coefficient Values.</li> <li>If both X and Y are 1-d, returns a single float.</li> <li>If X is numpy object, returns a 2-D numpy array.</li> <li>Otherwise returns a pd.DataFrame.</li> </ul> <code>Union[_RetType, Tuple[_RetType, _RetType]]</code> <ul> <li>P-Values (only when get_p_values are true):</li> <li>Same format at Xi</li> </ul> Source code in <code>xicorpy/correlation.py</code> <pre><code>def compute_xi(\n    self,\n    get_modified_xi: bool = None,\n    m_nearest_neighbours: int = None,\n    get_p_values: bool = False,\n) -&gt; Union[_RetType, Tuple[_RetType, _RetType]]:\n    \"\"\"\n    Compute the Xi Coefficient (Chatterjee's Rank Correlation) between columns in X and Y.\n\n    Xi Coefficient based on:\n        [Chatterjee (2020). \"A new coefficient of correlation\"](https://arxiv.org/abs/1909.10140)\n\n\n    Modified Xi Coefficient based on:\n        [Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\"](https://arxiv.org/abs/2108.06828)\n\n    The modified Xi Coefficient looks at M nearest neighbours to compute the correlation.\n    This allows the coefficient to converge much faster. However, it is computationally slightly more intensive.\n    For very large data, the two are likely to be very similar. We recommend using the modified Xi Coefficient.\n\n    Args:\n        get_modified_xi: Should the modified xi be computed?\n                Defaults to True when there are no ties, and False when ties are present.\n        m_nearest_neighbours: Only used when get_modified_xi is True.\n                Defaults to square-root of array size.\n        get_p_values: Should the p-values be computed?\n                The null hypothesis is that Y is completely independent of X (i.e., xi = 0).\n\n    Returns:\n        float/np.ndarray/pd.DataFrame:\n        - Xi Coefficient Values.\n            - If both X and Y are 1-d, returns a single float.\n            - If X is numpy object, returns a 2-D numpy array.\n            - Otherwise returns a pd.DataFrame.\n        - P-Values (only when get_p_values are true):\n            - Same format at Xi\n\n    \"\"\"\n    if get_modified_xi is False:\n        pass\n    else:\n        ties = _check_ties(self.x_df, self.y_df)\n        if ties:\n            if get_modified_xi is True:\n                warnings.warn(\n                    \"Cannot use modified xi when there are ties present. Either explicitly set\"\n                    \"`get_modified_xi=False` or leave as `None` to accept automatic decision.\",\n                    RuntimeWarning,\n                )\n            else:\n                get_modified_xi = False\n        elif get_modified_xi is None:\n            get_modified_xi = True\n\n    ret = pd.DataFrame(0.0, index=self.x_df.columns, columns=self.y_df.columns)\n    _, p = _get_p_no_ties(0, self.x_df.shape[0])\n    p_values = pd.DataFrame(p, index=self.x_df.columns, columns=self.y_df.columns)\n\n    for i in self.x_df.columns:\n        i_col: pd.Series = self.x_df[i]\n        if i_col.min() == i_col.max():  # pragma: no cover\n            # Constant column. Correlation will anyway be 0.\n            ret.loc[i] = 0\n        else:\n            if i_col.hasnans:\n                i_col = i_col.dropna()\n\n            if i_col.shape[0] &lt;= 2:  # pragma: no cover\n                # Not enough samples to compute correlation.\n                ret.loc[i] = 0\n            else:\n                # Sort once to avoid sorting each time we compute correlation.\n                i_col = i_col.sort_values(kind=\"stable\")\n                for j in self.y_df.columns:\n                    j_col: pd.Series = self.y_df.loc[i_col.index, j]\n                    if j_col.hasnans:\n                        j_col = j_col.dropna()\n\n                    if get_p_values:\n                        xi, sd, p = _single_pair(  # type: ignore\n                            i_col,\n                            j_col,\n                            get_modified_xi,\n                            m_nearest_neighbours,\n                            True,\n                        )\n                        ret.loc[i, j] = xi\n                        p_values.loc[i, j] = p\n                    else:\n                        ret.loc[i, j] = _single_pair(\n                            i_col,\n                            j_col,\n                            get_modified_xi,\n                            m_nearest_neighbours,\n                            False,\n                        )\n\n    if (\n        isinstance(self._x, list)\n        and isinstance(self._y, list)\n        and np.ndim(self._x) == 1\n        and np.ndim(self._y) == 1\n    ):\n        if get_p_values:\n            return ret.values[0, 0], p_values.values[0, 0]\n        else:\n            return ret.values[0, 0]\n\n    if isinstance(self._x, np.ndarray):\n        ret = ret.values\n        p_values = p_values.values\n\n    if get_p_values:\n        return ret, p_values\n\n    return ret\n</code></pre>"},{"location":"xicor_api/#xicorpy.correlation.compute_xi_correlation","title":"<code>compute_xi_correlation(x, y=None, get_modified_xi=None, m_nearest_neighbours=None, get_p_values=False)</code>","text":"<p>Helper function to compute the Xi Coefficient - uses the class machinery from <code>XiCorrelation</code>.</p> <p>Compute the Xi Coefficient (Chatterjee's Rank Correlation) between columns in X and Y.</p> Xi Coefficient based on <p>Chatterjee (2020). \"A new coefficient of correlation\"</p> Modified Xi Coefficient based on <p>Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\"</p> <p>The modified Xi Coefficient looks at M nearest neighbours to compute the correlation. This allows the coefficient to converge much faster. However, it is computationally slightly more intensive. For very large data, the two are likely to be very similar. We recommend using the modified Xi Coefficient.</p> <p>If only X is passed, computes correlation between each column of X. If Y is also passed, computes correlation between each column of X vs each column of Y.</p> <p>If only X is passed, X MUST be 2-d. Otherwise, both X and Y can be 1-d</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> required <code>y</code> <code>npt.ArrayLike</code> <p>A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.</p> <code>None</code> <code>get_modified_xi</code> <code>bool</code> <p>Should the modified xi be computed? By default this is True when there are no ties and False when ties are present</p> <code>None</code> <code>m_nearest_neighbours</code> <code>int</code> <p>Only used if get_modified_xi is True.</p> <code>None</code> <code>get_p_values</code> <code>bool</code> <p>Should the p-values be computed?             The null hypothesis is that Y is completely independent of X (i.e., xi = 0).</p> <code>False</code> <p>Returns:</p> Type Description <code>Union[_RetType, Tuple[_RetType, _RetType]]</code> <p>float/np.ndarray/pd.DataFrame:</p> <code>Union[_RetType, Tuple[_RetType, _RetType]]</code> <ul> <li>Xi Coefficient Values.</li> <li>If both X and Y are 1-d, returns a single float.</li> <li>If X is numpy object, returns a 2-D numpy array.</li> <li>Otherwise returns a pd.DataFrame.</li> </ul> <code>Union[_RetType, Tuple[_RetType, _RetType]]</code> <ul> <li>P-Values (only if get_p_values are true):</li> <li>Same format at Xi</li> </ul> Source code in <code>xicorpy/correlation.py</code> <pre><code>def compute_xi_correlation(\n    x: npt.ArrayLike,\n    y: npt.ArrayLike = None,\n    get_modified_xi: bool = None,\n    m_nearest_neighbours: int = None,\n    get_p_values: bool = False,\n) -&gt; Union[_RetType, Tuple[_RetType, _RetType]]:\n    \"\"\"\n    Helper function to compute the Xi Coefficient - uses the class machinery from `XiCorrelation`.\n\n    Compute the Xi Coefficient (Chatterjee's Rank Correlation) between columns in X and Y.\n\n    Xi Coefficient based on:\n        [Chatterjee (2020). \"A new coefficient of correlation\"](https://arxiv.org/abs/1909.10140)\n\n\n    Modified Xi Coefficient based on:\n        [Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\"](https://arxiv.org/abs/2108.06828)\n\n    The modified Xi Coefficient looks at M nearest neighbours to compute the correlation.\n    This allows the coefficient to converge much faster. However, it is computationally slightly more intensive.\n    For very large data, the two are likely to be very similar. We recommend using the modified Xi Coefficient.\n\n    If only X is passed, computes correlation between each column of X.\n    If Y is also passed, computes correlation between each column of X vs each column of Y.\n\n    If only X is passed, X MUST be 2-d. Otherwise, both X and Y can be 1-d\n\n    Args:\n        x (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n        y (npt.ArrayLike): A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame.\n        get_modified_xi: Should the modified xi be computed? By default this is True when there are no ties and False when ties are present\n        m_nearest_neighbours: Only used if get_modified_xi is True.\n        get_p_values: Should the p-values be computed?\n                        The null hypothesis is that Y is completely independent of X (i.e., xi = 0).\n\n    Returns:\n        float/np.ndarray/pd.DataFrame:\n        - Xi Coefficient Values.\n            - If both X and Y are 1-d, returns a single float.\n            - If X is numpy object, returns a 2-D numpy array.\n            - Otherwise returns a pd.DataFrame.\n        - P-Values (only if get_p_values are true):\n            - Same format at Xi\n\n\n    \"\"\"\n    return XiCorrelation(x, y).compute_xi(\n        get_modified_xi, m_nearest_neighbours, get_p_values\n    )\n</code></pre>"}]}
{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Chatterjee's Xi, its Applications, and Offshoots XicorPy is a Python package implementing Chatterjee's Xi, and its various offshoots. The package currently implements: Chatterjee's Xi from [1] Modified Xi from [2] Codependence Coefficient from [3] Feature Selection Algorithm (FOCI) from [3] Installation The package is available on PyPI. You can install using pip: pip install xicorpy . Usage import xicorpy x = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5] y = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68] xi = xicorpy.compute_xi_correlation(x, y) xi, p_value = xicorpy.compute_xi_correlation(x, y, get_p_values=True) Refer to Documentation for more details. Citations Chatterjee (2020). \"A new coefficient of correlation\" Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\"","title":"Home"},{"location":"#chatterjees-xi-its-applications-and-offshoots","text":"XicorPy is a Python package implementing Chatterjee's Xi, and its various offshoots. The package currently implements: Chatterjee's Xi from [1] Modified Xi from [2] Codependence Coefficient from [3] Feature Selection Algorithm (FOCI) from [3]","title":"Chatterjee's Xi, its Applications, and Offshoots"},{"location":"#installation","text":"The package is available on PyPI. You can install using pip: pip install xicorpy .","title":"Installation"},{"location":"#usage","text":"import xicorpy x = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5] y = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68] xi = xicorpy.compute_xi_correlation(x, y) xi, p_value = xicorpy.compute_xi_correlation(x, y, get_p_values=True) Refer to Documentation for more details.","title":"Usage"},{"location":"#citations","text":"Chatterjee (2020). \"A new coefficient of correlation\" Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" Azadkia and Chatterjee (2021). \"A simple measure of conditional dependence\"","title":"Citations"},{"location":"xi/","text":"Chatterjee's Xi Coefficient Chatterjee's Xi is a measures if Y is a function of X . The coefficient is 0 if X and Y are independent, and 1 if Y is a measurable function of X. Xi is computed by comparing ranks of consecutive values of X when Y is sorted. Lin and Han's [2] modification makes the original formulation more robust by comparing M right-neighbours. When M == 1, it reduces to the original formulation. Do note that this formulation is asymmetric : Xi(X, Y): Measures Y as a function of X Xi (Y, X): Measures X as a function of Y Xi (X, Y) != Xi (Y, X) To illustrate this better, consider the following example: X Y 8 6.58 8 5.76 8 7.71 8 8.84 8 8.47 8 7.04 8 5.25 19 12.5 8 5.56 8 7.91 8 6.89 This is the 4th dataset of Anscombe\u2019s quartet While we cannot have an estimate of Y given X, we can estimate X given Y - If Y < 10: X = 8, else X = 19 . Direction Chatterjee's Xi Modified Xi Xi (X, Y) 0.175 0.111 Xi (Y, X) 0.45 0.75 The above table also illustrates the impact of Lin and Han's modification. For very large data, the two are likely to be very similar, and for smaller data, Lin and Han's formulation tends to be appropriate. Usage import xicorpy x = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5] y = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68] xi = xicorpy.compute_xi_correlation(x, y) ## Get p-values: xi, p_value = xicorpy.compute_xi_correlation(x, y, get_p_values=True) ## Explicitly specify m-nearest-neighbours: xi = xicorpy.compute_xi_correlation(x, y, m_nearest_neighbours=5) ## Compute original formulation without Lin and Han's Modification: xi = xicorpy.compute_xi_correlation(x, y, get_modified_xi=False) Compute correlations between all columns in X vs all columns in Y: import pandas as pd import xicorpy x = pd.DataFrame({ \"x_1\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_2\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_3\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_4\": [8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8], }) y = pd.DataFrame({ \"y_1\": [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68], \"y_2\": [9.14, 8.14, 8.74, 8.77, 9.26, 8.1, 6.13, 3.1, 9.13, 7.26, 4.74], \"y_3\": [7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73], \"y_4\": [6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.5, 5.56, 7.91, 6.89], }) xi = xicorpy.compute_xi_correlation(x, y) Compute correlations between all columns in X: import pandas as pd import xicorpy x = pd.DataFrame({ \"x_1\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_2\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"y_1\": [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68], \"y_2\": [9.14, 8.14, 8.74, 8.77, 9.26, 8.1, 6.13, 3.1, 9.13, 7.26, 4.74], }) xi = xicorpy.compute_xi_correlation(x) Citations Chatterjee (2020). \"A new coefficient of correlation\" Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\"","title":"Chatterjee's Xi"},{"location":"xi/#chatterjees-xi-coefficient","text":"Chatterjee's Xi is a measures if Y is a function of X . The coefficient is 0 if X and Y are independent, and 1 if Y is a measurable function of X. Xi is computed by comparing ranks of consecutive values of X when Y is sorted. Lin and Han's [2] modification makes the original formulation more robust by comparing M right-neighbours. When M == 1, it reduces to the original formulation. Do note that this formulation is asymmetric : Xi(X, Y): Measures Y as a function of X Xi (Y, X): Measures X as a function of Y Xi (X, Y) != Xi (Y, X) To illustrate this better, consider the following example: X Y 8 6.58 8 5.76 8 7.71 8 8.84 8 8.47 8 7.04 8 5.25 19 12.5 8 5.56 8 7.91 8 6.89 This is the 4th dataset of Anscombe\u2019s quartet While we cannot have an estimate of Y given X, we can estimate X given Y - If Y < 10: X = 8, else X = 19 . Direction Chatterjee's Xi Modified Xi Xi (X, Y) 0.175 0.111 Xi (Y, X) 0.45 0.75 The above table also illustrates the impact of Lin and Han's modification. For very large data, the two are likely to be very similar, and for smaller data, Lin and Han's formulation tends to be appropriate.","title":"Chatterjee's Xi Coefficient"},{"location":"xi/#usage","text":"import xicorpy x = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5] y = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68] xi = xicorpy.compute_xi_correlation(x, y) ## Get p-values: xi, p_value = xicorpy.compute_xi_correlation(x, y, get_p_values=True) ## Explicitly specify m-nearest-neighbours: xi = xicorpy.compute_xi_correlation(x, y, m_nearest_neighbours=5) ## Compute original formulation without Lin and Han's Modification: xi = xicorpy.compute_xi_correlation(x, y, get_modified_xi=False) Compute correlations between all columns in X vs all columns in Y: import pandas as pd import xicorpy x = pd.DataFrame({ \"x_1\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_2\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_3\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_4\": [8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8], }) y = pd.DataFrame({ \"y_1\": [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68], \"y_2\": [9.14, 8.14, 8.74, 8.77, 9.26, 8.1, 6.13, 3.1, 9.13, 7.26, 4.74], \"y_3\": [7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73], \"y_4\": [6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.5, 5.56, 7.91, 6.89], }) xi = xicorpy.compute_xi_correlation(x, y) Compute correlations between all columns in X: import pandas as pd import xicorpy x = pd.DataFrame({ \"x_1\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"x_2\": [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5], \"y_1\": [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68], \"y_2\": [9.14, 8.14, 8.74, 8.77, 9.26, 8.1, 6.13, 3.1, 9.13, 7.26, 4.74], }) xi = xicorpy.compute_xi_correlation(x)","title":"Usage"},{"location":"xi/#citations","text":"Chatterjee (2020). \"A new coefficient of correlation\" Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\"","title":"Citations"},{"location":"xicor/","text":"Workflow module XiCorrelation Class containing Xi Correlation computation components __init__ ( self , x , y = None ) special If only x is passed, computes correlation between each column of x . If y is also passed, computes correlation between each column of x vs each column of y . If only x is passed, x MUST be 2-d. Otherwise, both x and y can be 1-d Parameters: Name Type Description Default x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required y npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None Exceptions: Type Description ValueError If x and y are not of the same shape. ValueError If there's less than 2 columns to compute correlation. compute_xi ( self , get_modified_xi = True , m_nearest_neighbours = None , get_p_values = False ) Compute the Xi Coefficient (Chatterjee's Rank Correlation) between columns in X and Y. Xi Coefficient based on: Chatterjee (2020). \"A new coefficient of correlation\" Modified Xi Coefficient based on: Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" The modified Xi Coefficient looks at M nearest neighbours to compute the correlation. This allows the coefficient to converge much faster. However, it is computationally slightly more intensive. For very large data, the two are likely to be very similar. We recommend using the modified Xi Coefficient. Parameters: Name Type Description Default get_modified_xi bool Should the modified xi be computed? True m_nearest_neighbours int Only used if get_modified_xi is True. None get_p_values bool Should the p-values be computed? The null hypothesis is that Y is completely independent of X (i.e., xi = 0). False Returns: Type Description float/np.ndarray/pd.DataFrame Xi Coefficient Values. If both X and Y are 1-d, returns a single float. If X is numpy object, returns a 2-D numpy array. Otherwise returns a pd.DataFrame. P-Values (only if get_p_values are true): Same format at Xi compute_xi_correlation ( x , y = None , get_modified_xi = True , m_nearest_neighbours = None , get_p_values = False ) Helper function to compute the Xi Coefficient - uses the class machinery from XiCorrelation . Compute the Xi Coefficient (Chatterjee's Rank Correlation) between columns in X and Y. Xi Coefficient based on: Chatterjee (2020). \"A new coefficient of correlation\" Modified Xi Coefficient based on: Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" The modified Xi Coefficient looks at M nearest neighbours to compute the correlation. This allows the coefficient to converge much faster. However, it is computationally slightly more intensive. For very large data, the two are likely to be very similar. We recommend using the modified Xi Coefficient. If only X is passed, computes correlation between each column of X. If Y is also passed, computes correlation between each column of X vs each column of Y. If only X is passed, X MUST be 2-d. Otherwise, both X and Y can be 1-d Parameters: Name Type Description Default x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required y npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None get_modified_xi bool Should the modified xi be computed? True m_nearest_neighbours int Only used if get_modified_xi is True. None get_p_values bool Should the p-values be computed? The null hypothesis is that Y is completely independent of X (i.e., xi = 0). False Returns: Type Description float/np.ndarray/pd.DataFrame Xi Coefficient Values. If both X and Y are 1-d, returns a single float. If X is numpy object, returns a 2-D numpy array. Otherwise returns a pd.DataFrame. P-Values (only if get_p_values are true): Same format at Xi","title":"XiCor"},{"location":"xicor/#workflow-module","text":"","title":"Workflow module"},{"location":"xicor/#src.correlation.XiCorrelation","text":"Class containing Xi Correlation computation components","title":"XiCorrelation"},{"location":"xicor/#src.correlation.XiCorrelation.__init__","text":"If only x is passed, computes correlation between each column of x . If y is also passed, computes correlation between each column of x vs each column of y . If only x is passed, x MUST be 2-d. Otherwise, both x and y can be 1-d Parameters: Name Type Description Default x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required y npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None Exceptions: Type Description ValueError If x and y are not of the same shape. ValueError If there's less than 2 columns to compute correlation.","title":"__init__()"},{"location":"xicor/#src.correlation.XiCorrelation.compute_xi","text":"Compute the Xi Coefficient (Chatterjee's Rank Correlation) between columns in X and Y. Xi Coefficient based on: Chatterjee (2020). \"A new coefficient of correlation\" Modified Xi Coefficient based on: Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" The modified Xi Coefficient looks at M nearest neighbours to compute the correlation. This allows the coefficient to converge much faster. However, it is computationally slightly more intensive. For very large data, the two are likely to be very similar. We recommend using the modified Xi Coefficient. Parameters: Name Type Description Default get_modified_xi bool Should the modified xi be computed? True m_nearest_neighbours int Only used if get_modified_xi is True. None get_p_values bool Should the p-values be computed? The null hypothesis is that Y is completely independent of X (i.e., xi = 0). False Returns: Type Description float/np.ndarray/pd.DataFrame Xi Coefficient Values. If both X and Y are 1-d, returns a single float. If X is numpy object, returns a 2-D numpy array. Otherwise returns a pd.DataFrame. P-Values (only if get_p_values are true): Same format at Xi","title":"compute_xi()"},{"location":"xicor/#src.correlation.compute_xi_correlation","text":"Helper function to compute the Xi Coefficient - uses the class machinery from XiCorrelation . Compute the Xi Coefficient (Chatterjee's Rank Correlation) between columns in X and Y. Xi Coefficient based on: Chatterjee (2020). \"A new coefficient of correlation\" Modified Xi Coefficient based on: Lin and Han (2021). \"On boosting the power of Chatterjee's rank correlation\" The modified Xi Coefficient looks at M nearest neighbours to compute the correlation. This allows the coefficient to converge much faster. However, it is computationally slightly more intensive. For very large data, the two are likely to be very similar. We recommend using the modified Xi Coefficient. If only X is passed, computes correlation between each column of X. If Y is also passed, computes correlation between each column of X vs each column of Y. If only X is passed, X MUST be 2-d. Otherwise, both X and Y can be 1-d Parameters: Name Type Description Default x npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. required y npt.ArrayLike A single list or list of lists or 1D/2D numpy array or pd.Series or pd.DataFrame. None get_modified_xi bool Should the modified xi be computed? True m_nearest_neighbours int Only used if get_modified_xi is True. None get_p_values bool Should the p-values be computed? The null hypothesis is that Y is completely independent of X (i.e., xi = 0). False Returns: Type Description float/np.ndarray/pd.DataFrame Xi Coefficient Values. If both X and Y are 1-d, returns a single float. If X is numpy object, returns a 2-D numpy array. Otherwise returns a pd.DataFrame. P-Values (only if get_p_values are true): Same format at Xi","title":"compute_xi_correlation()"}]}